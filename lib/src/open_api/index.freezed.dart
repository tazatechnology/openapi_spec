// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'index.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

OAuthFlows _$OAuthFlowsFromJson(Map<String, dynamic> json) {
  return _OAuthFlows.fromJson(json);
}

/// @nodoc
mixin _$OAuthFlows {
  OAuthFlow? get implicit => throw _privateConstructorUsedError;
  OAuthFlow? get password => throw _privateConstructorUsedError;
  OAuthFlow? get clientCredentials => throw _privateConstructorUsedError;
  OAuthFlow? get authorizationCode => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OAuthFlowsCopyWith<OAuthFlows> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OAuthFlowsCopyWith<$Res> {
  factory $OAuthFlowsCopyWith(
          OAuthFlows value, $Res Function(OAuthFlows) then) =
      _$OAuthFlowsCopyWithImpl<$Res, OAuthFlows>;
  @useResult
  $Res call(
      {OAuthFlow? implicit,
      OAuthFlow? password,
      OAuthFlow? clientCredentials,
      OAuthFlow? authorizationCode});

  $OAuthFlowCopyWith<$Res>? get implicit;
  $OAuthFlowCopyWith<$Res>? get password;
  $OAuthFlowCopyWith<$Res>? get clientCredentials;
  $OAuthFlowCopyWith<$Res>? get authorizationCode;
}

/// @nodoc
class _$OAuthFlowsCopyWithImpl<$Res, $Val extends OAuthFlows>
    implements $OAuthFlowsCopyWith<$Res> {
  _$OAuthFlowsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? implicit = freezed,
    Object? password = freezed,
    Object? clientCredentials = freezed,
    Object? authorizationCode = freezed,
  }) {
    return _then(_value.copyWith(
      implicit: freezed == implicit
          ? _value.implicit
          : implicit // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
      password: freezed == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
      clientCredentials: freezed == clientCredentials
          ? _value.clientCredentials
          : clientCredentials // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
      authorizationCode: freezed == authorizationCode
          ? _value.authorizationCode
          : authorizationCode // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $OAuthFlowCopyWith<$Res>? get implicit {
    if (_value.implicit == null) {
      return null;
    }

    return $OAuthFlowCopyWith<$Res>(_value.implicit!, (value) {
      return _then(_value.copyWith(implicit: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OAuthFlowCopyWith<$Res>? get password {
    if (_value.password == null) {
      return null;
    }

    return $OAuthFlowCopyWith<$Res>(_value.password!, (value) {
      return _then(_value.copyWith(password: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OAuthFlowCopyWith<$Res>? get clientCredentials {
    if (_value.clientCredentials == null) {
      return null;
    }

    return $OAuthFlowCopyWith<$Res>(_value.clientCredentials!, (value) {
      return _then(_value.copyWith(clientCredentials: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OAuthFlowCopyWith<$Res>? get authorizationCode {
    if (_value.authorizationCode == null) {
      return null;
    }

    return $OAuthFlowCopyWith<$Res>(_value.authorizationCode!, (value) {
      return _then(_value.copyWith(authorizationCode: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_OAuthFlowsCopyWith<$Res>
    implements $OAuthFlowsCopyWith<$Res> {
  factory _$$_OAuthFlowsCopyWith(
          _$_OAuthFlows value, $Res Function(_$_OAuthFlows) then) =
      __$$_OAuthFlowsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {OAuthFlow? implicit,
      OAuthFlow? password,
      OAuthFlow? clientCredentials,
      OAuthFlow? authorizationCode});

  @override
  $OAuthFlowCopyWith<$Res>? get implicit;
  @override
  $OAuthFlowCopyWith<$Res>? get password;
  @override
  $OAuthFlowCopyWith<$Res>? get clientCredentials;
  @override
  $OAuthFlowCopyWith<$Res>? get authorizationCode;
}

/// @nodoc
class __$$_OAuthFlowsCopyWithImpl<$Res>
    extends _$OAuthFlowsCopyWithImpl<$Res, _$_OAuthFlows>
    implements _$$_OAuthFlowsCopyWith<$Res> {
  __$$_OAuthFlowsCopyWithImpl(
      _$_OAuthFlows _value, $Res Function(_$_OAuthFlows) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? implicit = freezed,
    Object? password = freezed,
    Object? clientCredentials = freezed,
    Object? authorizationCode = freezed,
  }) {
    return _then(_$_OAuthFlows(
      implicit: freezed == implicit
          ? _value.implicit
          : implicit // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
      password: freezed == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
      clientCredentials: freezed == clientCredentials
          ? _value.clientCredentials
          : clientCredentials // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
      authorizationCode: freezed == authorizationCode
          ? _value.authorizationCode
          : authorizationCode // ignore: cast_nullable_to_non_nullable
              as OAuthFlow?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OAuthFlows implements _OAuthFlows {
  const _$_OAuthFlows(
      {this.implicit,
      this.password,
      this.clientCredentials,
      this.authorizationCode});

  factory _$_OAuthFlows.fromJson(Map<String, dynamic> json) =>
      _$$_OAuthFlowsFromJson(json);

  @override
  final OAuthFlow? implicit;
  @override
  final OAuthFlow? password;
  @override
  final OAuthFlow? clientCredentials;
  @override
  final OAuthFlow? authorizationCode;

  @override
  String toString() {
    return 'OAuthFlows(implicit: $implicit, password: $password, clientCredentials: $clientCredentials, authorizationCode: $authorizationCode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OAuthFlows &&
            (identical(other.implicit, implicit) ||
                other.implicit == implicit) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.clientCredentials, clientCredentials) ||
                other.clientCredentials == clientCredentials) &&
            (identical(other.authorizationCode, authorizationCode) ||
                other.authorizationCode == authorizationCode));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, implicit, password, clientCredentials, authorizationCode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OAuthFlowsCopyWith<_$_OAuthFlows> get copyWith =>
      __$$_OAuthFlowsCopyWithImpl<_$_OAuthFlows>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OAuthFlowsToJson(
      this,
    );
  }
}

abstract class _OAuthFlows implements OAuthFlows {
  const factory _OAuthFlows(
      {final OAuthFlow? implicit,
      final OAuthFlow? password,
      final OAuthFlow? clientCredentials,
      final OAuthFlow? authorizationCode}) = _$_OAuthFlows;

  factory _OAuthFlows.fromJson(Map<String, dynamic> json) =
      _$_OAuthFlows.fromJson;

  @override
  OAuthFlow? get implicit;
  @override
  OAuthFlow? get password;
  @override
  OAuthFlow? get clientCredentials;
  @override
  OAuthFlow? get authorizationCode;
  @override
  @JsonKey(ignore: true)
  _$$_OAuthFlowsCopyWith<_$_OAuthFlows> get copyWith =>
      throw _privateConstructorUsedError;
}

OAuthFlow _$OAuthFlowFromJson(Map<String, dynamic> json) {
  switch (json['unionType']) {
    case 'implicit':
      return _OAuthFlowImplicit.fromJson(json);
    case 'password':
      return _OAuthFlowPassword.fromJson(json);
    case 'clientCredentials':
      return _OAuthFlowClientCredentials.fromJson(json);
    case 'authorizationCode':
      return _OAuthFlowAuthorizationCode.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'unionType', 'OAuthFlow',
          'Invalid union type "${json['unionType']}"!');
  }
}

/// @nodoc
mixin _$OAuthFlow {
  String? get refreshUrl => throw _privateConstructorUsedError;
  Map<String, String> get scopes => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)
        implicit,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        password,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        clientCredentials,
    required TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)
        authorizationCode,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult? Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OAuthFlowImplicit value) implicit,
    required TResult Function(_OAuthFlowPassword value) password,
    required TResult Function(_OAuthFlowClientCredentials value)
        clientCredentials,
    required TResult Function(_OAuthFlowAuthorizationCode value)
        authorizationCode,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OAuthFlowImplicit value)? implicit,
    TResult? Function(_OAuthFlowPassword value)? password,
    TResult? Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult? Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OAuthFlowImplicit value)? implicit,
    TResult Function(_OAuthFlowPassword value)? password,
    TResult Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OAuthFlowCopyWith<OAuthFlow> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OAuthFlowCopyWith<$Res> {
  factory $OAuthFlowCopyWith(OAuthFlow value, $Res Function(OAuthFlow) then) =
      _$OAuthFlowCopyWithImpl<$Res, OAuthFlow>;
  @useResult
  $Res call({String? refreshUrl, Map<String, String> scopes});
}

/// @nodoc
class _$OAuthFlowCopyWithImpl<$Res, $Val extends OAuthFlow>
    implements $OAuthFlowCopyWith<$Res> {
  _$OAuthFlowCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? refreshUrl = freezed,
    Object? scopes = null,
  }) {
    return _then(_value.copyWith(
      refreshUrl: freezed == refreshUrl
          ? _value.refreshUrl
          : refreshUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value.scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_OAuthFlowImplicitCopyWith<$Res>
    implements $OAuthFlowCopyWith<$Res> {
  factory _$$_OAuthFlowImplicitCopyWith(_$_OAuthFlowImplicit value,
          $Res Function(_$_OAuthFlowImplicit) then) =
      __$$_OAuthFlowImplicitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String authorizationUrl,
      String? refreshUrl,
      Map<String, String> scopes});
}

/// @nodoc
class __$$_OAuthFlowImplicitCopyWithImpl<$Res>
    extends _$OAuthFlowCopyWithImpl<$Res, _$_OAuthFlowImplicit>
    implements _$$_OAuthFlowImplicitCopyWith<$Res> {
  __$$_OAuthFlowImplicitCopyWithImpl(
      _$_OAuthFlowImplicit _value, $Res Function(_$_OAuthFlowImplicit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? authorizationUrl = null,
    Object? refreshUrl = freezed,
    Object? scopes = null,
  }) {
    return _then(_$_OAuthFlowImplicit(
      authorizationUrl: null == authorizationUrl
          ? _value.authorizationUrl
          : authorizationUrl // ignore: cast_nullable_to_non_nullable
              as String,
      refreshUrl: freezed == refreshUrl
          ? _value.refreshUrl
          : refreshUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value._scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OAuthFlowImplicit implements _OAuthFlowImplicit {
  const _$_OAuthFlowImplicit(
      {required this.authorizationUrl,
      this.refreshUrl,
      required final Map<String, String> scopes,
      final String? $type})
      : _scopes = scopes,
        $type = $type ?? 'implicit';

  factory _$_OAuthFlowImplicit.fromJson(Map<String, dynamic> json) =>
      _$$_OAuthFlowImplicitFromJson(json);

  @override
  final String authorizationUrl;
  @override
  final String? refreshUrl;
  final Map<String, String> _scopes;
  @override
  Map<String, String> get scopes {
    if (_scopes is EqualUnmodifiableMapView) return _scopes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_scopes);
  }

  @JsonKey(name: 'unionType')
  final String $type;

  @override
  String toString() {
    return 'OAuthFlow.implicit(authorizationUrl: $authorizationUrl, refreshUrl: $refreshUrl, scopes: $scopes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OAuthFlowImplicit &&
            (identical(other.authorizationUrl, authorizationUrl) ||
                other.authorizationUrl == authorizationUrl) &&
            (identical(other.refreshUrl, refreshUrl) ||
                other.refreshUrl == refreshUrl) &&
            const DeepCollectionEquality().equals(other._scopes, _scopes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationUrl, refreshUrl,
      const DeepCollectionEquality().hash(_scopes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OAuthFlowImplicitCopyWith<_$_OAuthFlowImplicit> get copyWith =>
      __$$_OAuthFlowImplicitCopyWithImpl<_$_OAuthFlowImplicit>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)
        implicit,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        password,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        clientCredentials,
    required TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)
        authorizationCode,
  }) {
    return implicit(authorizationUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult? Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
  }) {
    return implicit?.call(authorizationUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
    required TResult orElse(),
  }) {
    if (implicit != null) {
      return implicit(authorizationUrl, refreshUrl, scopes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OAuthFlowImplicit value) implicit,
    required TResult Function(_OAuthFlowPassword value) password,
    required TResult Function(_OAuthFlowClientCredentials value)
        clientCredentials,
    required TResult Function(_OAuthFlowAuthorizationCode value)
        authorizationCode,
  }) {
    return implicit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OAuthFlowImplicit value)? implicit,
    TResult? Function(_OAuthFlowPassword value)? password,
    TResult? Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult? Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
  }) {
    return implicit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OAuthFlowImplicit value)? implicit,
    TResult Function(_OAuthFlowPassword value)? password,
    TResult Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
    required TResult orElse(),
  }) {
    if (implicit != null) {
      return implicit(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_OAuthFlowImplicitToJson(
      this,
    );
  }
}

abstract class _OAuthFlowImplicit implements OAuthFlow {
  const factory _OAuthFlowImplicit(
      {required final String authorizationUrl,
      final String? refreshUrl,
      required final Map<String, String> scopes}) = _$_OAuthFlowImplicit;

  factory _OAuthFlowImplicit.fromJson(Map<String, dynamic> json) =
      _$_OAuthFlowImplicit.fromJson;

  String get authorizationUrl;
  @override
  String? get refreshUrl;
  @override
  Map<String, String> get scopes;
  @override
  @JsonKey(ignore: true)
  _$$_OAuthFlowImplicitCopyWith<_$_OAuthFlowImplicit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_OAuthFlowPasswordCopyWith<$Res>
    implements $OAuthFlowCopyWith<$Res> {
  factory _$$_OAuthFlowPasswordCopyWith(_$_OAuthFlowPassword value,
          $Res Function(_$_OAuthFlowPassword) then) =
      __$$_OAuthFlowPasswordCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String tokenUrl, String? refreshUrl, Map<String, String> scopes});
}

/// @nodoc
class __$$_OAuthFlowPasswordCopyWithImpl<$Res>
    extends _$OAuthFlowCopyWithImpl<$Res, _$_OAuthFlowPassword>
    implements _$$_OAuthFlowPasswordCopyWith<$Res> {
  __$$_OAuthFlowPasswordCopyWithImpl(
      _$_OAuthFlowPassword _value, $Res Function(_$_OAuthFlowPassword) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokenUrl = null,
    Object? refreshUrl = freezed,
    Object? scopes = null,
  }) {
    return _then(_$_OAuthFlowPassword(
      tokenUrl: null == tokenUrl
          ? _value.tokenUrl
          : tokenUrl // ignore: cast_nullable_to_non_nullable
              as String,
      refreshUrl: freezed == refreshUrl
          ? _value.refreshUrl
          : refreshUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value._scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OAuthFlowPassword implements _OAuthFlowPassword {
  const _$_OAuthFlowPassword(
      {required this.tokenUrl,
      this.refreshUrl,
      required final Map<String, String> scopes,
      final String? $type})
      : _scopes = scopes,
        $type = $type ?? 'password';

  factory _$_OAuthFlowPassword.fromJson(Map<String, dynamic> json) =>
      _$$_OAuthFlowPasswordFromJson(json);

  @override
  final String tokenUrl;
  @override
  final String? refreshUrl;
  final Map<String, String> _scopes;
  @override
  Map<String, String> get scopes {
    if (_scopes is EqualUnmodifiableMapView) return _scopes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_scopes);
  }

  @JsonKey(name: 'unionType')
  final String $type;

  @override
  String toString() {
    return 'OAuthFlow.password(tokenUrl: $tokenUrl, refreshUrl: $refreshUrl, scopes: $scopes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OAuthFlowPassword &&
            (identical(other.tokenUrl, tokenUrl) ||
                other.tokenUrl == tokenUrl) &&
            (identical(other.refreshUrl, refreshUrl) ||
                other.refreshUrl == refreshUrl) &&
            const DeepCollectionEquality().equals(other._scopes, _scopes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, tokenUrl, refreshUrl,
      const DeepCollectionEquality().hash(_scopes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OAuthFlowPasswordCopyWith<_$_OAuthFlowPassword> get copyWith =>
      __$$_OAuthFlowPasswordCopyWithImpl<_$_OAuthFlowPassword>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)
        implicit,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        password,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        clientCredentials,
    required TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)
        authorizationCode,
  }) {
    return password(tokenUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult? Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
  }) {
    return password?.call(tokenUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
    required TResult orElse(),
  }) {
    if (password != null) {
      return password(tokenUrl, refreshUrl, scopes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OAuthFlowImplicit value) implicit,
    required TResult Function(_OAuthFlowPassword value) password,
    required TResult Function(_OAuthFlowClientCredentials value)
        clientCredentials,
    required TResult Function(_OAuthFlowAuthorizationCode value)
        authorizationCode,
  }) {
    return password(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OAuthFlowImplicit value)? implicit,
    TResult? Function(_OAuthFlowPassword value)? password,
    TResult? Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult? Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
  }) {
    return password?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OAuthFlowImplicit value)? implicit,
    TResult Function(_OAuthFlowPassword value)? password,
    TResult Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
    required TResult orElse(),
  }) {
    if (password != null) {
      return password(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_OAuthFlowPasswordToJson(
      this,
    );
  }
}

abstract class _OAuthFlowPassword implements OAuthFlow {
  const factory _OAuthFlowPassword(
      {required final String tokenUrl,
      final String? refreshUrl,
      required final Map<String, String> scopes}) = _$_OAuthFlowPassword;

  factory _OAuthFlowPassword.fromJson(Map<String, dynamic> json) =
      _$_OAuthFlowPassword.fromJson;

  String get tokenUrl;
  @override
  String? get refreshUrl;
  @override
  Map<String, String> get scopes;
  @override
  @JsonKey(ignore: true)
  _$$_OAuthFlowPasswordCopyWith<_$_OAuthFlowPassword> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_OAuthFlowClientCredentialsCopyWith<$Res>
    implements $OAuthFlowCopyWith<$Res> {
  factory _$$_OAuthFlowClientCredentialsCopyWith(
          _$_OAuthFlowClientCredentials value,
          $Res Function(_$_OAuthFlowClientCredentials) then) =
      __$$_OAuthFlowClientCredentialsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String tokenUrl, String? refreshUrl, Map<String, String> scopes});
}

/// @nodoc
class __$$_OAuthFlowClientCredentialsCopyWithImpl<$Res>
    extends _$OAuthFlowCopyWithImpl<$Res, _$_OAuthFlowClientCredentials>
    implements _$$_OAuthFlowClientCredentialsCopyWith<$Res> {
  __$$_OAuthFlowClientCredentialsCopyWithImpl(
      _$_OAuthFlowClientCredentials _value,
      $Res Function(_$_OAuthFlowClientCredentials) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokenUrl = null,
    Object? refreshUrl = freezed,
    Object? scopes = null,
  }) {
    return _then(_$_OAuthFlowClientCredentials(
      tokenUrl: null == tokenUrl
          ? _value.tokenUrl
          : tokenUrl // ignore: cast_nullable_to_non_nullable
              as String,
      refreshUrl: freezed == refreshUrl
          ? _value.refreshUrl
          : refreshUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value._scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OAuthFlowClientCredentials implements _OAuthFlowClientCredentials {
  const _$_OAuthFlowClientCredentials(
      {required this.tokenUrl,
      this.refreshUrl,
      required final Map<String, String> scopes,
      final String? $type})
      : _scopes = scopes,
        $type = $type ?? 'clientCredentials';

  factory _$_OAuthFlowClientCredentials.fromJson(Map<String, dynamic> json) =>
      _$$_OAuthFlowClientCredentialsFromJson(json);

  @override
  final String tokenUrl;
  @override
  final String? refreshUrl;
  final Map<String, String> _scopes;
  @override
  Map<String, String> get scopes {
    if (_scopes is EqualUnmodifiableMapView) return _scopes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_scopes);
  }

  @JsonKey(name: 'unionType')
  final String $type;

  @override
  String toString() {
    return 'OAuthFlow.clientCredentials(tokenUrl: $tokenUrl, refreshUrl: $refreshUrl, scopes: $scopes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OAuthFlowClientCredentials &&
            (identical(other.tokenUrl, tokenUrl) ||
                other.tokenUrl == tokenUrl) &&
            (identical(other.refreshUrl, refreshUrl) ||
                other.refreshUrl == refreshUrl) &&
            const DeepCollectionEquality().equals(other._scopes, _scopes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, tokenUrl, refreshUrl,
      const DeepCollectionEquality().hash(_scopes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OAuthFlowClientCredentialsCopyWith<_$_OAuthFlowClientCredentials>
      get copyWith => __$$_OAuthFlowClientCredentialsCopyWithImpl<
          _$_OAuthFlowClientCredentials>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)
        implicit,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        password,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        clientCredentials,
    required TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)
        authorizationCode,
  }) {
    return clientCredentials(tokenUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult? Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
  }) {
    return clientCredentials?.call(tokenUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
    required TResult orElse(),
  }) {
    if (clientCredentials != null) {
      return clientCredentials(tokenUrl, refreshUrl, scopes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OAuthFlowImplicit value) implicit,
    required TResult Function(_OAuthFlowPassword value) password,
    required TResult Function(_OAuthFlowClientCredentials value)
        clientCredentials,
    required TResult Function(_OAuthFlowAuthorizationCode value)
        authorizationCode,
  }) {
    return clientCredentials(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OAuthFlowImplicit value)? implicit,
    TResult? Function(_OAuthFlowPassword value)? password,
    TResult? Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult? Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
  }) {
    return clientCredentials?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OAuthFlowImplicit value)? implicit,
    TResult Function(_OAuthFlowPassword value)? password,
    TResult Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
    required TResult orElse(),
  }) {
    if (clientCredentials != null) {
      return clientCredentials(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_OAuthFlowClientCredentialsToJson(
      this,
    );
  }
}

abstract class _OAuthFlowClientCredentials implements OAuthFlow {
  const factory _OAuthFlowClientCredentials(
          {required final String tokenUrl,
          final String? refreshUrl,
          required final Map<String, String> scopes}) =
      _$_OAuthFlowClientCredentials;

  factory _OAuthFlowClientCredentials.fromJson(Map<String, dynamic> json) =
      _$_OAuthFlowClientCredentials.fromJson;

  String get tokenUrl;
  @override
  String? get refreshUrl;
  @override
  Map<String, String> get scopes;
  @override
  @JsonKey(ignore: true)
  _$$_OAuthFlowClientCredentialsCopyWith<_$_OAuthFlowClientCredentials>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_OAuthFlowAuthorizationCodeCopyWith<$Res>
    implements $OAuthFlowCopyWith<$Res> {
  factory _$$_OAuthFlowAuthorizationCodeCopyWith(
          _$_OAuthFlowAuthorizationCode value,
          $Res Function(_$_OAuthFlowAuthorizationCode) then) =
      __$$_OAuthFlowAuthorizationCodeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String authorizationUrl,
      String tokenUrl,
      String? refreshUrl,
      Map<String, String> scopes});
}

/// @nodoc
class __$$_OAuthFlowAuthorizationCodeCopyWithImpl<$Res>
    extends _$OAuthFlowCopyWithImpl<$Res, _$_OAuthFlowAuthorizationCode>
    implements _$$_OAuthFlowAuthorizationCodeCopyWith<$Res> {
  __$$_OAuthFlowAuthorizationCodeCopyWithImpl(
      _$_OAuthFlowAuthorizationCode _value,
      $Res Function(_$_OAuthFlowAuthorizationCode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? authorizationUrl = null,
    Object? tokenUrl = null,
    Object? refreshUrl = freezed,
    Object? scopes = null,
  }) {
    return _then(_$_OAuthFlowAuthorizationCode(
      authorizationUrl: null == authorizationUrl
          ? _value.authorizationUrl
          : authorizationUrl // ignore: cast_nullable_to_non_nullable
              as String,
      tokenUrl: null == tokenUrl
          ? _value.tokenUrl
          : tokenUrl // ignore: cast_nullable_to_non_nullable
              as String,
      refreshUrl: freezed == refreshUrl
          ? _value.refreshUrl
          : refreshUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value._scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OAuthFlowAuthorizationCode implements _OAuthFlowAuthorizationCode {
  const _$_OAuthFlowAuthorizationCode(
      {required this.authorizationUrl,
      required this.tokenUrl,
      this.refreshUrl,
      required final Map<String, String> scopes,
      final String? $type})
      : _scopes = scopes,
        $type = $type ?? 'authorizationCode';

  factory _$_OAuthFlowAuthorizationCode.fromJson(Map<String, dynamic> json) =>
      _$$_OAuthFlowAuthorizationCodeFromJson(json);

  @override
  final String authorizationUrl;
  @override
  final String tokenUrl;
  @override
  final String? refreshUrl;
  final Map<String, String> _scopes;
  @override
  Map<String, String> get scopes {
    if (_scopes is EqualUnmodifiableMapView) return _scopes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_scopes);
  }

  @JsonKey(name: 'unionType')
  final String $type;

  @override
  String toString() {
    return 'OAuthFlow.authorizationCode(authorizationUrl: $authorizationUrl, tokenUrl: $tokenUrl, refreshUrl: $refreshUrl, scopes: $scopes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OAuthFlowAuthorizationCode &&
            (identical(other.authorizationUrl, authorizationUrl) ||
                other.authorizationUrl == authorizationUrl) &&
            (identical(other.tokenUrl, tokenUrl) ||
                other.tokenUrl == tokenUrl) &&
            (identical(other.refreshUrl, refreshUrl) ||
                other.refreshUrl == refreshUrl) &&
            const DeepCollectionEquality().equals(other._scopes, _scopes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, authorizationUrl, tokenUrl,
      refreshUrl, const DeepCollectionEquality().hash(_scopes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OAuthFlowAuthorizationCodeCopyWith<_$_OAuthFlowAuthorizationCode>
      get copyWith => __$$_OAuthFlowAuthorizationCodeCopyWithImpl<
          _$_OAuthFlowAuthorizationCode>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)
        implicit,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        password,
    required TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)
        clientCredentials,
    required TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)
        authorizationCode,
  }) {
    return authorizationCode(authorizationUrl, tokenUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult? Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult? Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
  }) {
    return authorizationCode?.call(
        authorizationUrl, tokenUrl, refreshUrl, scopes);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String authorizationUrl, String? refreshUrl,
            Map<String, String> scopes)?
        implicit,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        password,
    TResult Function(
            String tokenUrl, String? refreshUrl, Map<String, String> scopes)?
        clientCredentials,
    TResult Function(String authorizationUrl, String tokenUrl,
            String? refreshUrl, Map<String, String> scopes)?
        authorizationCode,
    required TResult orElse(),
  }) {
    if (authorizationCode != null) {
      return authorizationCode(authorizationUrl, tokenUrl, refreshUrl, scopes);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_OAuthFlowImplicit value) implicit,
    required TResult Function(_OAuthFlowPassword value) password,
    required TResult Function(_OAuthFlowClientCredentials value)
        clientCredentials,
    required TResult Function(_OAuthFlowAuthorizationCode value)
        authorizationCode,
  }) {
    return authorizationCode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_OAuthFlowImplicit value)? implicit,
    TResult? Function(_OAuthFlowPassword value)? password,
    TResult? Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult? Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
  }) {
    return authorizationCode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_OAuthFlowImplicit value)? implicit,
    TResult Function(_OAuthFlowPassword value)? password,
    TResult Function(_OAuthFlowClientCredentials value)? clientCredentials,
    TResult Function(_OAuthFlowAuthorizationCode value)? authorizationCode,
    required TResult orElse(),
  }) {
    if (authorizationCode != null) {
      return authorizationCode(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_OAuthFlowAuthorizationCodeToJson(
      this,
    );
  }
}

abstract class _OAuthFlowAuthorizationCode implements OAuthFlow {
  const factory _OAuthFlowAuthorizationCode(
          {required final String authorizationUrl,
          required final String tokenUrl,
          final String? refreshUrl,
          required final Map<String, String> scopes}) =
      _$_OAuthFlowAuthorizationCode;

  factory _OAuthFlowAuthorizationCode.fromJson(Map<String, dynamic> json) =
      _$_OAuthFlowAuthorizationCode.fromJson;

  String get authorizationUrl;
  String get tokenUrl;
  @override
  String? get refreshUrl;
  @override
  Map<String, String> get scopes;
  @override
  @JsonKey(ignore: true)
  _$$_OAuthFlowAuthorizationCodeCopyWith<_$_OAuthFlowAuthorizationCode>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ApiCallback {
  /// The name of the callback
  String get name => throw _privateConstructorUsedError;

  /// The callback expression to evaluate and operation to perform
  Map<String, PathItem> get expression => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ApiCallbackCopyWith<ApiCallback> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiCallbackCopyWith<$Res> {
  factory $ApiCallbackCopyWith(
          ApiCallback value, $Res Function(ApiCallback) then) =
      _$ApiCallbackCopyWithImpl<$Res, ApiCallback>;
  @useResult
  $Res call({String name, Map<String, PathItem> expression});
}

/// @nodoc
class _$ApiCallbackCopyWithImpl<$Res, $Val extends ApiCallback>
    implements $ApiCallbackCopyWith<$Res> {
  _$ApiCallbackCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? expression = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      expression: null == expression
          ? _value.expression
          : expression // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ApiCallbackCopyWith<$Res>
    implements $ApiCallbackCopyWith<$Res> {
  factory _$$_ApiCallbackCopyWith(
          _$_ApiCallback value, $Res Function(_$_ApiCallback) then) =
      __$$_ApiCallbackCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, Map<String, PathItem> expression});
}

/// @nodoc
class __$$_ApiCallbackCopyWithImpl<$Res>
    extends _$ApiCallbackCopyWithImpl<$Res, _$_ApiCallback>
    implements _$$_ApiCallbackCopyWith<$Res> {
  __$$_ApiCallbackCopyWithImpl(
      _$_ApiCallback _value, $Res Function(_$_ApiCallback) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? expression = null,
  }) {
    return _then(_$_ApiCallback(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      expression: null == expression
          ? _value._expression
          : expression // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>,
    ));
  }
}

/// @nodoc

class _$_ApiCallback implements _ApiCallback {
  const _$_ApiCallback(
      {required this.name, required final Map<String, PathItem> expression})
      : _expression = expression;

  /// The name of the callback
  @override
  final String name;

  /// The callback expression to evaluate and operation to perform
  final Map<String, PathItem> _expression;

  /// The callback expression to evaluate and operation to perform
  @override
  Map<String, PathItem> get expression {
    if (_expression is EqualUnmodifiableMapView) return _expression;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_expression);
  }

  @override
  String toString() {
    return 'ApiCallback(name: $name, expression: $expression)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ApiCallback &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._expression, _expression));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(_expression));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ApiCallbackCopyWith<_$_ApiCallback> get copyWith =>
      __$$_ApiCallbackCopyWithImpl<_$_ApiCallback>(this, _$identity);
}

abstract class _ApiCallback implements ApiCallback {
  const factory _ApiCallback(
      {required final String name,
      required final Map<String, PathItem> expression}) = _$_ApiCallback;

  @override

  /// The name of the callback
  String get name;
  @override

  /// The callback expression to evaluate and operation to perform
  Map<String, PathItem> get expression;
  @override
  @JsonKey(ignore: true)
  _$$_ApiCallbackCopyWith<_$_ApiCallback> get copyWith =>
      throw _privateConstructorUsedError;
}

Components _$ComponentsFromJson(Map<String, dynamic> json) {
  return _Components.fromJson(json);
}

/// @nodoc
mixin _$Components {
  /// A set of reusable [Schema] objects.
  @_SchemaMapConverter()
  Map<String, Schema>? get schemas => throw _privateConstructorUsedError;

  /// A set of reusable [Response] objects.
  Map<String, Response>? get responses => throw _privateConstructorUsedError;

  /// A set of reusable [Parameter] objects.
  Map<String, Parameter>? get parameters => throw _privateConstructorUsedError;

  /// A set of reusable [Example] objects.
  Map<String, Example>? get examples => throw _privateConstructorUsedError;

  /// A set of reusable [RequestBody.component] objects.
  Map<String, RequestBody>? get requestBodies =>
      throw _privateConstructorUsedError;

  /// A set of reusable [Header] objects.
  Map<String, Header>? get headers => throw _privateConstructorUsedError;

  /// A set of reusable [SecurityScheme] objects.
  Map<String, SecurityScheme>? get securitySchemes =>
      throw _privateConstructorUsedError;

  /// A set of reusable [Link] objects.
  Map<String, Link>? get links => throw _privateConstructorUsedError;

  /// A set of reusable [ApiCallback] objects.
  @_ApiCallbackMapConverter()
  Map<String, ApiCallback>? get callbacks => throw _privateConstructorUsedError;

  /// A set of reusable [PathItem] objects.
  Map<String, PathItem>? get pathItems => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ComponentsCopyWith<Components> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComponentsCopyWith<$Res> {
  factory $ComponentsCopyWith(
          Components value, $Res Function(Components) then) =
      _$ComponentsCopyWithImpl<$Res, Components>;
  @useResult
  $Res call(
      {@_SchemaMapConverter() Map<String, Schema>? schemas,
      Map<String, Response>? responses,
      Map<String, Parameter>? parameters,
      Map<String, Example>? examples,
      Map<String, RequestBody>? requestBodies,
      Map<String, Header>? headers,
      Map<String, SecurityScheme>? securitySchemes,
      Map<String, Link>? links,
      @_ApiCallbackMapConverter() Map<String, ApiCallback>? callbacks,
      Map<String, PathItem>? pathItems});
}

/// @nodoc
class _$ComponentsCopyWithImpl<$Res, $Val extends Components>
    implements $ComponentsCopyWith<$Res> {
  _$ComponentsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schemas = freezed,
    Object? responses = freezed,
    Object? parameters = freezed,
    Object? examples = freezed,
    Object? requestBodies = freezed,
    Object? headers = freezed,
    Object? securitySchemes = freezed,
    Object? links = freezed,
    Object? callbacks = freezed,
    Object? pathItems = freezed,
  }) {
    return _then(_value.copyWith(
      schemas: freezed == schemas
          ? _value.schemas
          : schemas // ignore: cast_nullable_to_non_nullable
              as Map<String, Schema>?,
      responses: freezed == responses
          ? _value.responses
          : responses // ignore: cast_nullable_to_non_nullable
              as Map<String, Response>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, Parameter>?,
      examples: freezed == examples
          ? _value.examples
          : examples // ignore: cast_nullable_to_non_nullable
              as Map<String, Example>?,
      requestBodies: freezed == requestBodies
          ? _value.requestBodies
          : requestBodies // ignore: cast_nullable_to_non_nullable
              as Map<String, RequestBody>?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, Header>?,
      securitySchemes: freezed == securitySchemes
          ? _value.securitySchemes
          : securitySchemes // ignore: cast_nullable_to_non_nullable
              as Map<String, SecurityScheme>?,
      links: freezed == links
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as Map<String, Link>?,
      callbacks: freezed == callbacks
          ? _value.callbacks
          : callbacks // ignore: cast_nullable_to_non_nullable
              as Map<String, ApiCallback>?,
      pathItems: freezed == pathItems
          ? _value.pathItems
          : pathItems // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ComponentsCopyWith<$Res>
    implements $ComponentsCopyWith<$Res> {
  factory _$$_ComponentsCopyWith(
          _$_Components value, $Res Function(_$_Components) then) =
      __$$_ComponentsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@_SchemaMapConverter() Map<String, Schema>? schemas,
      Map<String, Response>? responses,
      Map<String, Parameter>? parameters,
      Map<String, Example>? examples,
      Map<String, RequestBody>? requestBodies,
      Map<String, Header>? headers,
      Map<String, SecurityScheme>? securitySchemes,
      Map<String, Link>? links,
      @_ApiCallbackMapConverter() Map<String, ApiCallback>? callbacks,
      Map<String, PathItem>? pathItems});
}

/// @nodoc
class __$$_ComponentsCopyWithImpl<$Res>
    extends _$ComponentsCopyWithImpl<$Res, _$_Components>
    implements _$$_ComponentsCopyWith<$Res> {
  __$$_ComponentsCopyWithImpl(
      _$_Components _value, $Res Function(_$_Components) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schemas = freezed,
    Object? responses = freezed,
    Object? parameters = freezed,
    Object? examples = freezed,
    Object? requestBodies = freezed,
    Object? headers = freezed,
    Object? securitySchemes = freezed,
    Object? links = freezed,
    Object? callbacks = freezed,
    Object? pathItems = freezed,
  }) {
    return _then(_$_Components(
      schemas: freezed == schemas
          ? _value._schemas
          : schemas // ignore: cast_nullable_to_non_nullable
              as Map<String, Schema>?,
      responses: freezed == responses
          ? _value._responses
          : responses // ignore: cast_nullable_to_non_nullable
              as Map<String, Response>?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, Parameter>?,
      examples: freezed == examples
          ? _value._examples
          : examples // ignore: cast_nullable_to_non_nullable
              as Map<String, Example>?,
      requestBodies: freezed == requestBodies
          ? _value._requestBodies
          : requestBodies // ignore: cast_nullable_to_non_nullable
              as Map<String, RequestBody>?,
      headers: freezed == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, Header>?,
      securitySchemes: freezed == securitySchemes
          ? _value._securitySchemes
          : securitySchemes // ignore: cast_nullable_to_non_nullable
              as Map<String, SecurityScheme>?,
      links: freezed == links
          ? _value._links
          : links // ignore: cast_nullable_to_non_nullable
              as Map<String, Link>?,
      callbacks: freezed == callbacks
          ? _value._callbacks
          : callbacks // ignore: cast_nullable_to_non_nullable
              as Map<String, ApiCallback>?,
      pathItems: freezed == pathItems
          ? _value._pathItems
          : pathItems // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Components implements _Components {
  const _$_Components(
      {@_SchemaMapConverter() final Map<String, Schema>? schemas,
      final Map<String, Response>? responses,
      final Map<String, Parameter>? parameters,
      final Map<String, Example>? examples,
      final Map<String, RequestBody>? requestBodies,
      final Map<String, Header>? headers,
      final Map<String, SecurityScheme>? securitySchemes,
      final Map<String, Link>? links,
      @_ApiCallbackMapConverter() final Map<String, ApiCallback>? callbacks,
      final Map<String, PathItem>? pathItems})
      : _schemas = schemas,
        _responses = responses,
        _parameters = parameters,
        _examples = examples,
        _requestBodies = requestBodies,
        _headers = headers,
        _securitySchemes = securitySchemes,
        _links = links,
        _callbacks = callbacks,
        _pathItems = pathItems;

  factory _$_Components.fromJson(Map<String, dynamic> json) =>
      _$$_ComponentsFromJson(json);

  /// A set of reusable [Schema] objects.
  final Map<String, Schema>? _schemas;

  /// A set of reusable [Schema] objects.
  @override
  @_SchemaMapConverter()
  Map<String, Schema>? get schemas {
    final value = _schemas;
    if (value == null) return null;
    if (_schemas is EqualUnmodifiableMapView) return _schemas;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [Response] objects.
  final Map<String, Response>? _responses;

  /// A set of reusable [Response] objects.
  @override
  Map<String, Response>? get responses {
    final value = _responses;
    if (value == null) return null;
    if (_responses is EqualUnmodifiableMapView) return _responses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [Parameter] objects.
  final Map<String, Parameter>? _parameters;

  /// A set of reusable [Parameter] objects.
  @override
  Map<String, Parameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [Example] objects.
  final Map<String, Example>? _examples;

  /// A set of reusable [Example] objects.
  @override
  Map<String, Example>? get examples {
    final value = _examples;
    if (value == null) return null;
    if (_examples is EqualUnmodifiableMapView) return _examples;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [RequestBody.component] objects.
  final Map<String, RequestBody>? _requestBodies;

  /// A set of reusable [RequestBody.component] objects.
  @override
  Map<String, RequestBody>? get requestBodies {
    final value = _requestBodies;
    if (value == null) return null;
    if (_requestBodies is EqualUnmodifiableMapView) return _requestBodies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [Header] objects.
  final Map<String, Header>? _headers;

  /// A set of reusable [Header] objects.
  @override
  Map<String, Header>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [SecurityScheme] objects.
  final Map<String, SecurityScheme>? _securitySchemes;

  /// A set of reusable [SecurityScheme] objects.
  @override
  Map<String, SecurityScheme>? get securitySchemes {
    final value = _securitySchemes;
    if (value == null) return null;
    if (_securitySchemes is EqualUnmodifiableMapView) return _securitySchemes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [Link] objects.
  final Map<String, Link>? _links;

  /// A set of reusable [Link] objects.
  @override
  Map<String, Link>? get links {
    final value = _links;
    if (value == null) return null;
    if (_links is EqualUnmodifiableMapView) return _links;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [ApiCallback] objects.
  final Map<String, ApiCallback>? _callbacks;

  /// A set of reusable [ApiCallback] objects.
  @override
  @_ApiCallbackMapConverter()
  Map<String, ApiCallback>? get callbacks {
    final value = _callbacks;
    if (value == null) return null;
    if (_callbacks is EqualUnmodifiableMapView) return _callbacks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A set of reusable [PathItem] objects.
  final Map<String, PathItem>? _pathItems;

  /// A set of reusable [PathItem] objects.
  @override
  Map<String, PathItem>? get pathItems {
    final value = _pathItems;
    if (value == null) return null;
    if (_pathItems is EqualUnmodifiableMapView) return _pathItems;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'Components(schemas: $schemas, responses: $responses, parameters: $parameters, examples: $examples, requestBodies: $requestBodies, headers: $headers, securitySchemes: $securitySchemes, links: $links, callbacks: $callbacks, pathItems: $pathItems)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Components &&
            const DeepCollectionEquality().equals(other._schemas, _schemas) &&
            const DeepCollectionEquality()
                .equals(other._responses, _responses) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality().equals(other._examples, _examples) &&
            const DeepCollectionEquality()
                .equals(other._requestBodies, _requestBodies) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            const DeepCollectionEquality()
                .equals(other._securitySchemes, _securitySchemes) &&
            const DeepCollectionEquality().equals(other._links, _links) &&
            const DeepCollectionEquality()
                .equals(other._callbacks, _callbacks) &&
            const DeepCollectionEquality()
                .equals(other._pathItems, _pathItems));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_schemas),
      const DeepCollectionEquality().hash(_responses),
      const DeepCollectionEquality().hash(_parameters),
      const DeepCollectionEquality().hash(_examples),
      const DeepCollectionEquality().hash(_requestBodies),
      const DeepCollectionEquality().hash(_headers),
      const DeepCollectionEquality().hash(_securitySchemes),
      const DeepCollectionEquality().hash(_links),
      const DeepCollectionEquality().hash(_callbacks),
      const DeepCollectionEquality().hash(_pathItems));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ComponentsCopyWith<_$_Components> get copyWith =>
      __$$_ComponentsCopyWithImpl<_$_Components>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ComponentsToJson(
      this,
    );
  }
}

abstract class _Components implements Components {
  const factory _Components(
      {@_SchemaMapConverter() final Map<String, Schema>? schemas,
      final Map<String, Response>? responses,
      final Map<String, Parameter>? parameters,
      final Map<String, Example>? examples,
      final Map<String, RequestBody>? requestBodies,
      final Map<String, Header>? headers,
      final Map<String, SecurityScheme>? securitySchemes,
      final Map<String, Link>? links,
      @_ApiCallbackMapConverter() final Map<String, ApiCallback>? callbacks,
      final Map<String, PathItem>? pathItems}) = _$_Components;

  factory _Components.fromJson(Map<String, dynamic> json) =
      _$_Components.fromJson;

  @override

  /// A set of reusable [Schema] objects.
  @_SchemaMapConverter()
  Map<String, Schema>? get schemas;
  @override

  /// A set of reusable [Response] objects.
  Map<String, Response>? get responses;
  @override

  /// A set of reusable [Parameter] objects.
  Map<String, Parameter>? get parameters;
  @override

  /// A set of reusable [Example] objects.
  Map<String, Example>? get examples;
  @override

  /// A set of reusable [RequestBody.component] objects.
  Map<String, RequestBody>? get requestBodies;
  @override

  /// A set of reusable [Header] objects.
  Map<String, Header>? get headers;
  @override

  /// A set of reusable [SecurityScheme] objects.
  Map<String, SecurityScheme>? get securitySchemes;
  @override

  /// A set of reusable [Link] objects.
  Map<String, Link>? get links;
  @override

  /// A set of reusable [ApiCallback] objects.
  @_ApiCallbackMapConverter()
  Map<String, ApiCallback>? get callbacks;
  @override

  /// A set of reusable [PathItem] objects.
  Map<String, PathItem>? get pathItems;
  @override
  @JsonKey(ignore: true)
  _$$_ComponentsCopyWith<_$_Components> get copyWith =>
      throw _privateConstructorUsedError;
}

Contact _$ContactFromJson(Map<String, dynamic> json) {
  return _Contact.fromJson(json);
}

/// @nodoc
mixin _$Contact {
  /// The identifying name of the contact person/organization.
  String? get name => throw _privateConstructorUsedError;

  /// The email address of the contact person/organization.
  /// This must be in the form of an email address.
  String? get email => throw _privateConstructorUsedError;

  /// The URL pointing to the contact information.
  /// This must be in the form of a URL.
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContactCopyWith<Contact> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContactCopyWith<$Res> {
  factory $ContactCopyWith(Contact value, $Res Function(Contact) then) =
      _$ContactCopyWithImpl<$Res, Contact>;
  @useResult
  $Res call({String? name, String? email, String? url});
}

/// @nodoc
class _$ContactCopyWithImpl<$Res, $Val extends Contact>
    implements $ContactCopyWith<$Res> {
  _$ContactCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? email = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ContactCopyWith<$Res> implements $ContactCopyWith<$Res> {
  factory _$$_ContactCopyWith(
          _$_Contact value, $Res Function(_$_Contact) then) =
      __$$_ContactCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? email, String? url});
}

/// @nodoc
class __$$_ContactCopyWithImpl<$Res>
    extends _$ContactCopyWithImpl<$Res, _$_Contact>
    implements _$$_ContactCopyWith<$Res> {
  __$$_ContactCopyWithImpl(_$_Contact _value, $Res Function(_$_Contact) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? email = freezed,
    Object? url = freezed,
  }) {
    return _then(_$_Contact(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Contact implements _Contact {
  const _$_Contact({this.name, this.email, this.url});

  factory _$_Contact.fromJson(Map<String, dynamic> json) =>
      _$$_ContactFromJson(json);

  /// The identifying name of the contact person/organization.
  @override
  final String? name;

  /// The email address of the contact person/organization.
  /// This must be in the form of an email address.
  @override
  final String? email;

  /// The URL pointing to the contact information.
  /// This must be in the form of a URL.
  @override
  final String? url;

  @override
  String toString() {
    return 'Contact(name: $name, email: $email, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Contact &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, email, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ContactCopyWith<_$_Contact> get copyWith =>
      __$$_ContactCopyWithImpl<_$_Contact>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ContactToJson(
      this,
    );
  }
}

abstract class _Contact implements Contact {
  const factory _Contact(
      {final String? name,
      final String? email,
      final String? url}) = _$_Contact;

  factory _Contact.fromJson(Map<String, dynamic> json) = _$_Contact.fromJson;

  @override

  /// The identifying name of the contact person/organization.
  String? get name;
  @override

  /// The email address of the contact person/organization.
  /// This must be in the form of an email address.
  String? get email;
  @override

  /// The URL pointing to the contact information.
  /// This must be in the form of a URL.
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$_ContactCopyWith<_$_Contact> get copyWith =>
      throw _privateConstructorUsedError;
}

Discriminator _$DiscriminatorFromJson(Map<String, dynamic> json) {
  return _Discriminator.fromJson(json);
}

/// @nodoc
mixin _$Discriminator {
  /// The name of the property in the payload that will hold the discriminator value.
  String get propertyName => throw _privateConstructorUsedError;

  /// An object to hold mappings between payload values and schema names or references.
  Map<String, String>? get mapping => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DiscriminatorCopyWith<Discriminator> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DiscriminatorCopyWith<$Res> {
  factory $DiscriminatorCopyWith(
          Discriminator value, $Res Function(Discriminator) then) =
      _$DiscriminatorCopyWithImpl<$Res, Discriminator>;
  @useResult
  $Res call({String propertyName, Map<String, String>? mapping});
}

/// @nodoc
class _$DiscriminatorCopyWithImpl<$Res, $Val extends Discriminator>
    implements $DiscriminatorCopyWith<$Res> {
  _$DiscriminatorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyName = null,
    Object? mapping = freezed,
  }) {
    return _then(_value.copyWith(
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      mapping: freezed == mapping
          ? _value.mapping
          : mapping // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DiscriminatorCopyWith<$Res>
    implements $DiscriminatorCopyWith<$Res> {
  factory _$$_DiscriminatorCopyWith(
          _$_Discriminator value, $Res Function(_$_Discriminator) then) =
      __$$_DiscriminatorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String propertyName, Map<String, String>? mapping});
}

/// @nodoc
class __$$_DiscriminatorCopyWithImpl<$Res>
    extends _$DiscriminatorCopyWithImpl<$Res, _$_Discriminator>
    implements _$$_DiscriminatorCopyWith<$Res> {
  __$$_DiscriminatorCopyWithImpl(
      _$_Discriminator _value, $Res Function(_$_Discriminator) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyName = null,
    Object? mapping = freezed,
  }) {
    return _then(_$_Discriminator(
      propertyName: null == propertyName
          ? _value.propertyName
          : propertyName // ignore: cast_nullable_to_non_nullable
              as String,
      mapping: freezed == mapping
          ? _value._mapping
          : mapping // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Discriminator implements _Discriminator {
  const _$_Discriminator(
      {required this.propertyName, final Map<String, String>? mapping})
      : _mapping = mapping;

  factory _$_Discriminator.fromJson(Map<String, dynamic> json) =>
      _$$_DiscriminatorFromJson(json);

  /// The name of the property in the payload that will hold the discriminator value.
  @override
  final String propertyName;

  /// An object to hold mappings between payload values and schema names or references.
  final Map<String, String>? _mapping;

  /// An object to hold mappings between payload values and schema names or references.
  @override
  Map<String, String>? get mapping {
    final value = _mapping;
    if (value == null) return null;
    if (_mapping is EqualUnmodifiableMapView) return _mapping;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'Discriminator(propertyName: $propertyName, mapping: $mapping)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Discriminator &&
            (identical(other.propertyName, propertyName) ||
                other.propertyName == propertyName) &&
            const DeepCollectionEquality().equals(other._mapping, _mapping));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, propertyName, const DeepCollectionEquality().hash(_mapping));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DiscriminatorCopyWith<_$_Discriminator> get copyWith =>
      __$$_DiscriminatorCopyWithImpl<_$_Discriminator>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DiscriminatorToJson(
      this,
    );
  }
}

abstract class _Discriminator implements Discriminator {
  const factory _Discriminator(
      {required final String propertyName,
      final Map<String, String>? mapping}) = _$_Discriminator;

  factory _Discriminator.fromJson(Map<String, dynamic> json) =
      _$_Discriminator.fromJson;

  @override

  /// The name of the property in the payload that will hold the discriminator value.
  String get propertyName;
  @override

  /// An object to hold mappings between payload values and schema names or references.
  Map<String, String>? get mapping;
  @override
  @JsonKey(ignore: true)
  _$$_DiscriminatorCopyWith<_$_Discriminator> get copyWith =>
      throw _privateConstructorUsedError;
}

Encoding _$EncodingFromJson(Map<String, dynamic> json) {
  return _Encoding.fromJson(json);
}

/// @nodoc
mixin _$Encoding {
  /// The Content-Type for encoding a specific property.
  String? get contentType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EncodingCopyWith<Encoding> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EncodingCopyWith<$Res> {
  factory $EncodingCopyWith(Encoding value, $Res Function(Encoding) then) =
      _$EncodingCopyWithImpl<$Res, Encoding>;
  @useResult
  $Res call({String? contentType});
}

/// @nodoc
class _$EncodingCopyWithImpl<$Res, $Val extends Encoding>
    implements $EncodingCopyWith<$Res> {
  _$EncodingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contentType = freezed,
  }) {
    return _then(_value.copyWith(
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_EncodingCopyWith<$Res> implements $EncodingCopyWith<$Res> {
  factory _$$_EncodingCopyWith(
          _$_Encoding value, $Res Function(_$_Encoding) then) =
      __$$_EncodingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? contentType});
}

/// @nodoc
class __$$_EncodingCopyWithImpl<$Res>
    extends _$EncodingCopyWithImpl<$Res, _$_Encoding>
    implements _$$_EncodingCopyWith<$Res> {
  __$$_EncodingCopyWithImpl(
      _$_Encoding _value, $Res Function(_$_Encoding) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contentType = freezed,
  }) {
    return _then(_$_Encoding(
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Encoding implements _Encoding {
  const _$_Encoding({this.contentType});

  factory _$_Encoding.fromJson(Map<String, dynamic> json) =>
      _$$_EncodingFromJson(json);

  /// The Content-Type for encoding a specific property.
  @override
  final String? contentType;

  @override
  String toString() {
    return 'Encoding(contentType: $contentType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Encoding &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, contentType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EncodingCopyWith<_$_Encoding> get copyWith =>
      __$$_EncodingCopyWithImpl<_$_Encoding>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_EncodingToJson(
      this,
    );
  }
}

abstract class _Encoding implements Encoding {
  const factory _Encoding({final String? contentType}) = _$_Encoding;

  factory _Encoding.fromJson(Map<String, dynamic> json) = _$_Encoding.fromJson;

  @override

  /// The Content-Type for encoding a specific property.
  String? get contentType;
  @override
  @JsonKey(ignore: true)
  _$$_EncodingCopyWith<_$_Encoding> get copyWith =>
      throw _privateConstructorUsedError;
}

Example _$ExampleFromJson(Map<String, dynamic> json) {
  return ExampleObject.fromJson(json);
}

/// @nodoc
mixin _$Example {
  /// Short description for the example.
  String? get summary => throw _privateConstructorUsedError;

  /// Long description for the example.
  String? get description => throw _privateConstructorUsedError;

  /// Embedded literal example
  dynamic get value => throw _privateConstructorUsedError;

  /// A URI that points to the literal example.
  String? get externalValue => throw _privateConstructorUsedError;

  /// Reference to a response defined in [Components.examples]
  @JsonKey(name: '\$ref')
  @_ExampleRefConverter()
  String? get ref => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExampleCopyWith<Example> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExampleCopyWith<$Res> {
  factory $ExampleCopyWith(Example value, $Res Function(Example) then) =
      _$ExampleCopyWithImpl<$Res, Example>;
  @useResult
  $Res call(
      {String? summary,
      String? description,
      dynamic value,
      String? externalValue,
      @JsonKey(name: '\$ref') @_ExampleRefConverter() String? ref});
}

/// @nodoc
class _$ExampleCopyWithImpl<$Res, $Val extends Example>
    implements $ExampleCopyWith<$Res> {
  _$ExampleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? description = freezed,
    Object? value = freezed,
    Object? externalValue = freezed,
    Object? ref = freezed,
  }) {
    return _then(_value.copyWith(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
      externalValue: freezed == externalValue
          ? _value.externalValue
          : externalValue // ignore: cast_nullable_to_non_nullable
              as String?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExampleObjectCopyWith<$Res>
    implements $ExampleCopyWith<$Res> {
  factory _$$ExampleObjectCopyWith(
          _$ExampleObject value, $Res Function(_$ExampleObject) then) =
      __$$ExampleObjectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? summary,
      String? description,
      dynamic value,
      String? externalValue,
      @JsonKey(name: '\$ref') @_ExampleRefConverter() String? ref});
}

/// @nodoc
class __$$ExampleObjectCopyWithImpl<$Res>
    extends _$ExampleCopyWithImpl<$Res, _$ExampleObject>
    implements _$$ExampleObjectCopyWith<$Res> {
  __$$ExampleObjectCopyWithImpl(
      _$ExampleObject _value, $Res Function(_$ExampleObject) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? description = freezed,
    Object? value = freezed,
    Object? externalValue = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$ExampleObject(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
      externalValue: freezed == externalValue
          ? _value.externalValue
          : externalValue // ignore: cast_nullable_to_non_nullable
              as String?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExampleObject extends ExampleObject {
  const _$ExampleObject(
      {this.summary,
      this.description,
      this.value,
      this.externalValue,
      @JsonKey(name: '\$ref') @_ExampleRefConverter() this.ref})
      : super._();

  factory _$ExampleObject.fromJson(Map<String, dynamic> json) =>
      _$$ExampleObjectFromJson(json);

  /// Short description for the example.
  @override
  final String? summary;

  /// Long description for the example.
  @override
  final String? description;

  /// Embedded literal example
  @override
  final dynamic value;

  /// A URI that points to the literal example.
  @override
  final String? externalValue;

  /// Reference to a response defined in [Components.examples]
  @override
  @JsonKey(name: '\$ref')
  @_ExampleRefConverter()
  final String? ref;

  @override
  String toString() {
    return 'Example(summary: $summary, description: $description, value: $value, externalValue: $externalValue, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExampleObject &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other.value, value) &&
            (identical(other.externalValue, externalValue) ||
                other.externalValue == externalValue) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, summary, description,
      const DeepCollectionEquality().hash(value), externalValue, ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExampleObjectCopyWith<_$ExampleObject> get copyWith =>
      __$$ExampleObjectCopyWithImpl<_$ExampleObject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExampleObjectToJson(
      this,
    );
  }
}

abstract class ExampleObject extends Example {
  const factory ExampleObject(
          {final String? summary,
          final String? description,
          final dynamic value,
          final String? externalValue,
          @JsonKey(name: '\$ref') @_ExampleRefConverter() final String? ref}) =
      _$ExampleObject;
  const ExampleObject._() : super._();

  factory ExampleObject.fromJson(Map<String, dynamic> json) =
      _$ExampleObject.fromJson;

  @override

  /// Short description for the example.
  String? get summary;
  @override

  /// Long description for the example.
  String? get description;
  @override

  /// Embedded literal example
  dynamic get value;
  @override

  /// A URI that points to the literal example.
  String? get externalValue;
  @override

  /// Reference to a response defined in [Components.examples]
  @JsonKey(name: '\$ref')
  @_ExampleRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$ExampleObjectCopyWith<_$ExampleObject> get copyWith =>
      throw _privateConstructorUsedError;
}

ExternalDocs _$ExternalDocsFromJson(Map<String, dynamic> json) {
  return _ExternalDocs.fromJson(json);
}

/// @nodoc
mixin _$ExternalDocs {
  /// A description of the target documentation.
  String? get description => throw _privateConstructorUsedError;

  /// The URL for the target documentation. This must be in the form of a URL.
  String get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalDocsCopyWith<ExternalDocs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalDocsCopyWith<$Res> {
  factory $ExternalDocsCopyWith(
          ExternalDocs value, $Res Function(ExternalDocs) then) =
      _$ExternalDocsCopyWithImpl<$Res, ExternalDocs>;
  @useResult
  $Res call({String? description, String url});
}

/// @nodoc
class _$ExternalDocsCopyWithImpl<$Res, $Val extends ExternalDocs>
    implements $ExternalDocsCopyWith<$Res> {
  _$ExternalDocsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? url = null,
  }) {
    return _then(_value.copyWith(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExternalDocsCopyWith<$Res>
    implements $ExternalDocsCopyWith<$Res> {
  factory _$$_ExternalDocsCopyWith(
          _$_ExternalDocs value, $Res Function(_$_ExternalDocs) then) =
      __$$_ExternalDocsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? description, String url});
}

/// @nodoc
class __$$_ExternalDocsCopyWithImpl<$Res>
    extends _$ExternalDocsCopyWithImpl<$Res, _$_ExternalDocs>
    implements _$$_ExternalDocsCopyWith<$Res> {
  __$$_ExternalDocsCopyWithImpl(
      _$_ExternalDocs _value, $Res Function(_$_ExternalDocs) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? url = null,
  }) {
    return _then(_$_ExternalDocs(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExternalDocs implements _ExternalDocs {
  const _$_ExternalDocs({this.description, required this.url});

  factory _$_ExternalDocs.fromJson(Map<String, dynamic> json) =>
      _$$_ExternalDocsFromJson(json);

  /// A description of the target documentation.
  @override
  final String? description;

  /// The URL for the target documentation. This must be in the form of a URL.
  @override
  final String url;

  @override
  String toString() {
    return 'ExternalDocs(description: $description, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExternalDocs &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExternalDocsCopyWith<_$_ExternalDocs> get copyWith =>
      __$$_ExternalDocsCopyWithImpl<_$_ExternalDocs>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExternalDocsToJson(
      this,
    );
  }
}

abstract class _ExternalDocs implements ExternalDocs {
  const factory _ExternalDocs(
      {final String? description, required final String url}) = _$_ExternalDocs;

  factory _ExternalDocs.fromJson(Map<String, dynamic> json) =
      _$_ExternalDocs.fromJson;

  @override

  /// A description of the target documentation.
  String? get description;
  @override

  /// The URL for the target documentation. This must be in the form of a URL.
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$_ExternalDocsCopyWith<_$_ExternalDocs> get copyWith =>
      throw _privateConstructorUsedError;
}

Header _$HeaderFromJson(Map<String, dynamic> json) {
  return _Header.fromJson(json);
}

/// @nodoc
mixin _$Header {
  /// Text
  String? get description => throw _privateConstructorUsedError;

  /// The schema of the content
  Schema? get schema => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $HeaderCopyWith<Header> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeaderCopyWith<$Res> {
  factory $HeaderCopyWith(Header value, $Res Function(Header) then) =
      _$HeaderCopyWithImpl<$Res, Header>;
  @useResult
  $Res call({String? description, Schema? schema});

  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class _$HeaderCopyWithImpl<$Res, $Val extends Header>
    implements $HeaderCopyWith<$Res> {
  _$HeaderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? schema = freezed,
  }) {
    return _then(_value.copyWith(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $SchemaCopyWith<$Res>? get schema {
    if (_value.schema == null) {
      return null;
    }

    return $SchemaCopyWith<$Res>(_value.schema!, (value) {
      return _then(_value.copyWith(schema: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_HeaderCopyWith<$Res> implements $HeaderCopyWith<$Res> {
  factory _$$_HeaderCopyWith(_$_Header value, $Res Function(_$_Header) then) =
      __$$_HeaderCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? description, Schema? schema});

  @override
  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class __$$_HeaderCopyWithImpl<$Res>
    extends _$HeaderCopyWithImpl<$Res, _$_Header>
    implements _$$_HeaderCopyWith<$Res> {
  __$$_HeaderCopyWithImpl(_$_Header _value, $Res Function(_$_Header) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? schema = freezed,
  }) {
    return _then(_$_Header(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Header implements _Header {
  const _$_Header({this.description, this.schema});

  factory _$_Header.fromJson(Map<String, dynamic> json) =>
      _$$_HeaderFromJson(json);

  /// Text
  @override
  final String? description;

  /// The schema of the content
  @override
  final Schema? schema;

  @override
  String toString() {
    return 'Header(description: $description, schema: $schema)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Header &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.schema, schema) || other.schema == schema));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description, schema);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_HeaderCopyWith<_$_Header> get copyWith =>
      __$$_HeaderCopyWithImpl<_$_Header>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_HeaderToJson(
      this,
    );
  }
}

abstract class _Header implements Header {
  const factory _Header({final String? description, final Schema? schema}) =
      _$_Header;

  factory _Header.fromJson(Map<String, dynamic> json) = _$_Header.fromJson;

  @override

  /// Text
  String? get description;
  @override

  /// The schema of the content
  Schema? get schema;
  @override
  @JsonKey(ignore: true)
  _$$_HeaderCopyWith<_$_Header> get copyWith =>
      throw _privateConstructorUsedError;
}

Info _$InfoFromJson(Map<String, dynamic> json) {
  return _Info.fromJson(json);
}

/// @nodoc
mixin _$Info {
  /// The title of the API.
  String get title => throw _privateConstructorUsedError;

  /// A short summary of the API.
  String? get summary => throw _privateConstructorUsedError;

  /// A description of the API.
  String? get description => throw _privateConstructorUsedError;

  /// A URL to the Terms of Service for the API.
  /// This must be in the form of a URL.
  String? get termsOfService => throw _privateConstructorUsedError;

  /// The contact information for the exposed API.
  Contact? get contact => throw _privateConstructorUsedError;

  /// The license information for the exposed API.
  License? get license => throw _privateConstructorUsedError;

  /// The version of the OpenAPI document. Distinct from [OpenApi.openapi].
  String get version => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InfoCopyWith<Info> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InfoCopyWith<$Res> {
  factory $InfoCopyWith(Info value, $Res Function(Info) then) =
      _$InfoCopyWithImpl<$Res, Info>;
  @useResult
  $Res call(
      {String title,
      String? summary,
      String? description,
      String? termsOfService,
      Contact? contact,
      License? license,
      String version});

  $ContactCopyWith<$Res>? get contact;
  $LicenseCopyWith<$Res>? get license;
}

/// @nodoc
class _$InfoCopyWithImpl<$Res, $Val extends Info>
    implements $InfoCopyWith<$Res> {
  _$InfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? summary = freezed,
    Object? description = freezed,
    Object? termsOfService = freezed,
    Object? contact = freezed,
    Object? license = freezed,
    Object? version = null,
  }) {
    return _then(_value.copyWith(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      termsOfService: freezed == termsOfService
          ? _value.termsOfService
          : termsOfService // ignore: cast_nullable_to_non_nullable
              as String?,
      contact: freezed == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Contact?,
      license: freezed == license
          ? _value.license
          : license // ignore: cast_nullable_to_non_nullable
              as License?,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ContactCopyWith<$Res>? get contact {
    if (_value.contact == null) {
      return null;
    }

    return $ContactCopyWith<$Res>(_value.contact!, (value) {
      return _then(_value.copyWith(contact: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $LicenseCopyWith<$Res>? get license {
    if (_value.license == null) {
      return null;
    }

    return $LicenseCopyWith<$Res>(_value.license!, (value) {
      return _then(_value.copyWith(license: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_InfoCopyWith<$Res> implements $InfoCopyWith<$Res> {
  factory _$$_InfoCopyWith(_$_Info value, $Res Function(_$_Info) then) =
      __$$_InfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String title,
      String? summary,
      String? description,
      String? termsOfService,
      Contact? contact,
      License? license,
      String version});

  @override
  $ContactCopyWith<$Res>? get contact;
  @override
  $LicenseCopyWith<$Res>? get license;
}

/// @nodoc
class __$$_InfoCopyWithImpl<$Res> extends _$InfoCopyWithImpl<$Res, _$_Info>
    implements _$$_InfoCopyWith<$Res> {
  __$$_InfoCopyWithImpl(_$_Info _value, $Res Function(_$_Info) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? summary = freezed,
    Object? description = freezed,
    Object? termsOfService = freezed,
    Object? contact = freezed,
    Object? license = freezed,
    Object? version = null,
  }) {
    return _then(_$_Info(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      termsOfService: freezed == termsOfService
          ? _value.termsOfService
          : termsOfService // ignore: cast_nullable_to_non_nullable
              as String?,
      contact: freezed == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as Contact?,
      license: freezed == license
          ? _value.license
          : license // ignore: cast_nullable_to_non_nullable
              as License?,
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Info implements _Info {
  const _$_Info(
      {required this.title,
      this.summary,
      this.description,
      this.termsOfService,
      this.contact,
      this.license,
      required this.version});

  factory _$_Info.fromJson(Map<String, dynamic> json) => _$$_InfoFromJson(json);

  /// The title of the API.
  @override
  final String title;

  /// A short summary of the API.
  @override
  final String? summary;

  /// A description of the API.
  @override
  final String? description;

  /// A URL to the Terms of Service for the API.
  /// This must be in the form of a URL.
  @override
  final String? termsOfService;

  /// The contact information for the exposed API.
  @override
  final Contact? contact;

  /// The license information for the exposed API.
  @override
  final License? license;

  /// The version of the OpenAPI document. Distinct from [OpenApi.openapi].
  @override
  final String version;

  @override
  String toString() {
    return 'Info(title: $title, summary: $summary, description: $description, termsOfService: $termsOfService, contact: $contact, license: $license, version: $version)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Info &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.termsOfService, termsOfService) ||
                other.termsOfService == termsOfService) &&
            (identical(other.contact, contact) || other.contact == contact) &&
            (identical(other.license, license) || other.license == license) &&
            (identical(other.version, version) || other.version == version));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, title, summary, description,
      termsOfService, contact, license, version);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InfoCopyWith<_$_Info> get copyWith =>
      __$$_InfoCopyWithImpl<_$_Info>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InfoToJson(
      this,
    );
  }
}

abstract class _Info implements Info {
  const factory _Info(
      {required final String title,
      final String? summary,
      final String? description,
      final String? termsOfService,
      final Contact? contact,
      final License? license,
      required final String version}) = _$_Info;

  factory _Info.fromJson(Map<String, dynamic> json) = _$_Info.fromJson;

  @override

  /// The title of the API.
  String get title;
  @override

  /// A short summary of the API.
  String? get summary;
  @override

  /// A description of the API.
  String? get description;
  @override

  /// A URL to the Terms of Service for the API.
  /// This must be in the form of a URL.
  String? get termsOfService;
  @override

  /// The contact information for the exposed API.
  Contact? get contact;
  @override

  /// The license information for the exposed API.
  License? get license;
  @override

  /// The version of the OpenAPI document. Distinct from [OpenApi.openapi].
  String get version;
  @override
  @JsonKey(ignore: true)
  _$$_InfoCopyWith<_$_Info> get copyWith => throw _privateConstructorUsedError;
}

License _$LicenseFromJson(Map<String, dynamic> json) {
  return _License.fromJson(json);
}

/// @nodoc
mixin _$License {
  /// The license name used for the API.
  String get name => throw _privateConstructorUsedError;

  /// An [SPDX](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60) license expression for the API.
  /// The identifier field is mutually exclusive of the url field.
  String? get identifier => throw _privateConstructorUsedError;

  /// A URL to the license used for the API. This must be in the form of a URL.
  /// The [url] field is mutually exclusive of the [identifier] field.
  String? get url => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LicenseCopyWith<License> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LicenseCopyWith<$Res> {
  factory $LicenseCopyWith(License value, $Res Function(License) then) =
      _$LicenseCopyWithImpl<$Res, License>;
  @useResult
  $Res call({String name, String? identifier, String? url});
}

/// @nodoc
class _$LicenseCopyWithImpl<$Res, $Val extends License>
    implements $LicenseCopyWith<$Res> {
  _$LicenseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? identifier = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LicenseCopyWith<$Res> implements $LicenseCopyWith<$Res> {
  factory _$$_LicenseCopyWith(
          _$_License value, $Res Function(_$_License) then) =
      __$$_LicenseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String? identifier, String? url});
}

/// @nodoc
class __$$_LicenseCopyWithImpl<$Res>
    extends _$LicenseCopyWithImpl<$Res, _$_License>
    implements _$$_LicenseCopyWith<$Res> {
  __$$_LicenseCopyWithImpl(_$_License _value, $Res Function(_$_License) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? identifier = freezed,
    Object? url = freezed,
  }) {
    return _then(_$_License(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_License implements _License {
  const _$_License({required this.name, this.identifier, this.url});

  factory _$_License.fromJson(Map<String, dynamic> json) =>
      _$$_LicenseFromJson(json);

  /// The license name used for the API.
  @override
  final String name;

  /// An [SPDX](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60) license expression for the API.
  /// The identifier field is mutually exclusive of the url field.
  @override
  final String? identifier;

  /// A URL to the license used for the API. This must be in the form of a URL.
  /// The [url] field is mutually exclusive of the [identifier] field.
  @override
  final String? url;

  @override
  String toString() {
    return 'License(name: $name, identifier: $identifier, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_License &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, identifier, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LicenseCopyWith<_$_License> get copyWith =>
      __$$_LicenseCopyWithImpl<_$_License>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LicenseToJson(
      this,
    );
  }
}

abstract class _License implements License {
  const factory _License(
      {required final String name,
      final String? identifier,
      final String? url}) = _$_License;

  factory _License.fromJson(Map<String, dynamic> json) = _$_License.fromJson;

  @override

  /// The license name used for the API.
  String get name;
  @override

  /// An [SPDX](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60) license expression for the API.
  /// The identifier field is mutually exclusive of the url field.
  String? get identifier;
  @override

  /// A URL to the license used for the API. This must be in the form of a URL.
  /// The [url] field is mutually exclusive of the [identifier] field.
  String? get url;
  @override
  @JsonKey(ignore: true)
  _$$_LicenseCopyWith<_$_License> get copyWith =>
      throw _privateConstructorUsedError;
}

Link _$LinkFromJson(Map<String, dynamic> json) {
  return _Link.fromJson(json);
}

/// @nodoc
mixin _$Link {
  /// A relative or absolute URI reference to an OAS operation.
  @JsonKey(name: '\$ref')
  @_LinkRefConverter()
  String? get ref => throw _privateConstructorUsedError;

  /// The name of an existing, resolvable OAS operation,
  /// as defined with a unique operationId.
  String? get operationId => throw _privateConstructorUsedError;

  /// A map representing parameters to pass to an operation
  /// as specified with operationId or identified via [ref].
  Map<String, String>? get parameters => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LinkCopyWith<Link> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LinkCopyWith<$Res> {
  factory $LinkCopyWith(Link value, $Res Function(Link) then) =
      _$LinkCopyWithImpl<$Res, Link>;
  @useResult
  $Res call(
      {@JsonKey(name: '\$ref') @_LinkRefConverter() String? ref,
      String? operationId,
      Map<String, String>? parameters});
}

/// @nodoc
class _$LinkCopyWithImpl<$Res, $Val extends Link>
    implements $LinkCopyWith<$Res> {
  _$LinkCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ref = freezed,
    Object? operationId = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_value.copyWith(
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
      operationId: freezed == operationId
          ? _value.operationId
          : operationId // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LinkCopyWith<$Res> implements $LinkCopyWith<$Res> {
  factory _$$_LinkCopyWith(_$_Link value, $Res Function(_$_Link) then) =
      __$$_LinkCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: '\$ref') @_LinkRefConverter() String? ref,
      String? operationId,
      Map<String, String>? parameters});
}

/// @nodoc
class __$$_LinkCopyWithImpl<$Res> extends _$LinkCopyWithImpl<$Res, _$_Link>
    implements _$$_LinkCopyWith<$Res> {
  __$$_LinkCopyWithImpl(_$_Link _value, $Res Function(_$_Link) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ref = freezed,
    Object? operationId = freezed,
    Object? parameters = freezed,
  }) {
    return _then(_$_Link(
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
      operationId: freezed == operationId
          ? _value.operationId
          : operationId // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Link implements _Link {
  const _$_Link(
      {@JsonKey(name: '\$ref') @_LinkRefConverter() this.ref,
      this.operationId,
      final Map<String, String>? parameters})
      : _parameters = parameters;

  factory _$_Link.fromJson(Map<String, dynamic> json) => _$$_LinkFromJson(json);

  /// A relative or absolute URI reference to an OAS operation.
  @override
  @JsonKey(name: '\$ref')
  @_LinkRefConverter()
  final String? ref;

  /// The name of an existing, resolvable OAS operation,
  /// as defined with a unique operationId.
  @override
  final String? operationId;

  /// A map representing parameters to pass to an operation
  /// as specified with operationId or identified via [ref].
  final Map<String, String>? _parameters;

  /// A map representing parameters to pass to an operation
  /// as specified with operationId or identified via [ref].
  @override
  Map<String, String>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableMapView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'Link(ref: $ref, operationId: $operationId, parameters: $parameters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Link &&
            (identical(other.ref, ref) || other.ref == ref) &&
            (identical(other.operationId, operationId) ||
                other.operationId == operationId) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, ref, operationId,
      const DeepCollectionEquality().hash(_parameters));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LinkCopyWith<_$_Link> get copyWith =>
      __$$_LinkCopyWithImpl<_$_Link>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LinkToJson(
      this,
    );
  }
}

abstract class _Link implements Link {
  const factory _Link(
      {@JsonKey(name: '\$ref') @_LinkRefConverter() final String? ref,
      final String? operationId,
      final Map<String, String>? parameters}) = _$_Link;

  factory _Link.fromJson(Map<String, dynamic> json) = _$_Link.fromJson;

  @override

  /// A relative or absolute URI reference to an OAS operation.
  @JsonKey(name: '\$ref')
  @_LinkRefConverter()
  String? get ref;
  @override

  /// The name of an existing, resolvable OAS operation,
  /// as defined with a unique operationId.
  String? get operationId;
  @override

  /// A map representing parameters to pass to an operation
  /// as specified with operationId or identified via [ref].
  Map<String, String>? get parameters;
  @override
  @JsonKey(ignore: true)
  _$$_LinkCopyWith<_$_Link> get copyWith => throw _privateConstructorUsedError;
}

MediaType _$MediaTypeFromJson(Map<String, dynamic> json) {
  return _MediaType.fromJson(json);
}

/// @nodoc
mixin _$MediaType {
  /// The schema defining the content of the request, response, or parameter.
  Schema? get schema => throw _privateConstructorUsedError;

  /// Example of the media type.
  dynamic get example =>
      throw _privateConstructorUsedError; // Examples of the media type.
  Map<String, Example>? get examples => throw _privateConstructorUsedError;

  /// A map between a property name and its encoding information.
  Map<String, Encoding>? get encoding => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MediaTypeCopyWith<MediaType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MediaTypeCopyWith<$Res> {
  factory $MediaTypeCopyWith(MediaType value, $Res Function(MediaType) then) =
      _$MediaTypeCopyWithImpl<$Res, MediaType>;
  @useResult
  $Res call(
      {Schema? schema,
      dynamic example,
      Map<String, Example>? examples,
      Map<String, Encoding>? encoding});

  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class _$MediaTypeCopyWithImpl<$Res, $Val extends MediaType>
    implements $MediaTypeCopyWith<$Res> {
  _$MediaTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schema = freezed,
    Object? example = freezed,
    Object? examples = freezed,
    Object? encoding = freezed,
  }) {
    return _then(_value.copyWith(
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as dynamic,
      examples: freezed == examples
          ? _value.examples
          : examples // ignore: cast_nullable_to_non_nullable
              as Map<String, Example>?,
      encoding: freezed == encoding
          ? _value.encoding
          : encoding // ignore: cast_nullable_to_non_nullable
              as Map<String, Encoding>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $SchemaCopyWith<$Res>? get schema {
    if (_value.schema == null) {
      return null;
    }

    return $SchemaCopyWith<$Res>(_value.schema!, (value) {
      return _then(_value.copyWith(schema: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MediaTypeCopyWith<$Res> implements $MediaTypeCopyWith<$Res> {
  factory _$$_MediaTypeCopyWith(
          _$_MediaType value, $Res Function(_$_MediaType) then) =
      __$$_MediaTypeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Schema? schema,
      dynamic example,
      Map<String, Example>? examples,
      Map<String, Encoding>? encoding});

  @override
  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class __$$_MediaTypeCopyWithImpl<$Res>
    extends _$MediaTypeCopyWithImpl<$Res, _$_MediaType>
    implements _$$_MediaTypeCopyWith<$Res> {
  __$$_MediaTypeCopyWithImpl(
      _$_MediaType _value, $Res Function(_$_MediaType) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schema = freezed,
    Object? example = freezed,
    Object? examples = freezed,
    Object? encoding = freezed,
  }) {
    return _then(_$_MediaType(
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as dynamic,
      examples: freezed == examples
          ? _value._examples
          : examples // ignore: cast_nullable_to_non_nullable
              as Map<String, Example>?,
      encoding: freezed == encoding
          ? _value._encoding
          : encoding // ignore: cast_nullable_to_non_nullable
              as Map<String, Encoding>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MediaType implements _MediaType {
  const _$_MediaType(
      {this.schema,
      this.example,
      final Map<String, Example>? examples,
      final Map<String, Encoding>? encoding})
      : _examples = examples,
        _encoding = encoding;

  factory _$_MediaType.fromJson(Map<String, dynamic> json) =>
      _$$_MediaTypeFromJson(json);

  /// The schema defining the content of the request, response, or parameter.
  @override
  final Schema? schema;

  /// Example of the media type.
  @override
  final dynamic example;
// Examples of the media type.
  final Map<String, Example>? _examples;
// Examples of the media type.
  @override
  Map<String, Example>? get examples {
    final value = _examples;
    if (value == null) return null;
    if (_examples is EqualUnmodifiableMapView) return _examples;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A map between a property name and its encoding information.
  final Map<String, Encoding>? _encoding;

  /// A map between a property name and its encoding information.
  @override
  Map<String, Encoding>? get encoding {
    final value = _encoding;
    if (value == null) return null;
    if (_encoding is EqualUnmodifiableMapView) return _encoding;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'MediaType(schema: $schema, example: $example, examples: $examples, encoding: $encoding)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MediaType &&
            (identical(other.schema, schema) || other.schema == schema) &&
            const DeepCollectionEquality().equals(other.example, example) &&
            const DeepCollectionEquality().equals(other._examples, _examples) &&
            const DeepCollectionEquality().equals(other._encoding, _encoding));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      schema,
      const DeepCollectionEquality().hash(example),
      const DeepCollectionEquality().hash(_examples),
      const DeepCollectionEquality().hash(_encoding));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MediaTypeCopyWith<_$_MediaType> get copyWith =>
      __$$_MediaTypeCopyWithImpl<_$_MediaType>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MediaTypeToJson(
      this,
    );
  }
}

abstract class _MediaType implements MediaType {
  const factory _MediaType(
      {final Schema? schema,
      final dynamic example,
      final Map<String, Example>? examples,
      final Map<String, Encoding>? encoding}) = _$_MediaType;

  factory _MediaType.fromJson(Map<String, dynamic> json) =
      _$_MediaType.fromJson;

  @override

  /// The schema defining the content of the request, response, or parameter.
  Schema? get schema;
  @override

  /// Example of the media type.
  dynamic get example;
  @override // Examples of the media type.
  Map<String, Example>? get examples;
  @override

  /// A map between a property name and its encoding information.
  Map<String, Encoding>? get encoding;
  @override
  @JsonKey(ignore: true)
  _$$_MediaTypeCopyWith<_$_MediaType> get copyWith =>
      throw _privateConstructorUsedError;
}

Operation _$OperationFromJson(Map<String, dynamic> json) {
  return _Operation.fromJson(json);
}

/// @nodoc
mixin _$Operation {
  /// A list of tags for API documentation control.
  List<String>? get tags => throw _privateConstructorUsedError;

  /// A short summary of what the operation does.
  String? get summary => throw _privateConstructorUsedError;

  /// An optional string describing the host designated by the URL.
  String? get description => throw _privateConstructorUsedError;

  /// Additional external documentation for this schema.
  ExternalDocs? get externalDocs => throw _privateConstructorUsedError;

  /// Unique string used to identify the operation.
  /// The id MUST be unique among all operations described in the API.
  @JsonKey(name: 'operationId')
  String? get id => throw _privateConstructorUsedError;

  /// A list of parameters that are applicable for this operation.
  /// If a parameter is already defined at the [PathItem] level,
  /// the new definition will override it but can never remove it.
  List<Parameter>? get parameters => throw _privateConstructorUsedError;

  /// The request body applicable for this operation.
  RequestBody? get requestBody => throw _privateConstructorUsedError;

  /// The list of possible responses as they are returned from executing this operation.
  Map<String, Response>? get responses => throw _privateConstructorUsedError;

  /// A map of possible out-of band callbacks related to the parent operation.
  /// The key is a unique identifier for the [ApiCallback] Object.
  @_ApiCallbackMapConverter()
  Map<String, ApiCallback>? get callbacks => throw _privateConstructorUsedError;

  /// Declares this operation to be deprecated.
  bool? get deprecated => throw _privateConstructorUsedError;

  /// A declaration of which security mechanisms can be used for this operation.
  /// The list of values includes alternative security requirement objects that can be used.
  List<Security>? get security => throw _privateConstructorUsedError;

  /// An alternative [Server] array to service this operation.
  /// If an alternative [Server] object is specified at the [PathItem] level,
  /// it will be overridden by this value.
  List<Server>? get servers => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OperationCopyWith<Operation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperationCopyWith<$Res> {
  factory $OperationCopyWith(Operation value, $Res Function(Operation) then) =
      _$OperationCopyWithImpl<$Res, Operation>;
  @useResult
  $Res call(
      {List<String>? tags,
      String? summary,
      String? description,
      ExternalDocs? externalDocs,
      @JsonKey(name: 'operationId') String? id,
      List<Parameter>? parameters,
      RequestBody? requestBody,
      Map<String, Response>? responses,
      @_ApiCallbackMapConverter() Map<String, ApiCallback>? callbacks,
      bool? deprecated,
      List<Security>? security,
      List<Server>? servers});

  $ExternalDocsCopyWith<$Res>? get externalDocs;
  $RequestBodyCopyWith<$Res>? get requestBody;
}

/// @nodoc
class _$OperationCopyWithImpl<$Res, $Val extends Operation>
    implements $OperationCopyWith<$Res> {
  _$OperationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = freezed,
    Object? summary = freezed,
    Object? description = freezed,
    Object? externalDocs = freezed,
    Object? id = freezed,
    Object? parameters = freezed,
    Object? requestBody = freezed,
    Object? responses = freezed,
    Object? callbacks = freezed,
    Object? deprecated = freezed,
    Object? security = freezed,
    Object? servers = freezed,
  }) {
    return _then(_value.copyWith(
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<Parameter>?,
      requestBody: freezed == requestBody
          ? _value.requestBody
          : requestBody // ignore: cast_nullable_to_non_nullable
              as RequestBody?,
      responses: freezed == responses
          ? _value.responses
          : responses // ignore: cast_nullable_to_non_nullable
              as Map<String, Response>?,
      callbacks: freezed == callbacks
          ? _value.callbacks
          : callbacks // ignore: cast_nullable_to_non_nullable
              as Map<String, ApiCallback>?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      security: freezed == security
          ? _value.security
          : security // ignore: cast_nullable_to_non_nullable
              as List<Security>?,
      servers: freezed == servers
          ? _value.servers
          : servers // ignore: cast_nullable_to_non_nullable
              as List<Server>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalDocsCopyWith<$Res>? get externalDocs {
    if (_value.externalDocs == null) {
      return null;
    }

    return $ExternalDocsCopyWith<$Res>(_value.externalDocs!, (value) {
      return _then(_value.copyWith(externalDocs: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RequestBodyCopyWith<$Res>? get requestBody {
    if (_value.requestBody == null) {
      return null;
    }

    return $RequestBodyCopyWith<$Res>(_value.requestBody!, (value) {
      return _then(_value.copyWith(requestBody: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_OperationCopyWith<$Res> implements $OperationCopyWith<$Res> {
  factory _$$_OperationCopyWith(
          _$_Operation value, $Res Function(_$_Operation) then) =
      __$$_OperationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<String>? tags,
      String? summary,
      String? description,
      ExternalDocs? externalDocs,
      @JsonKey(name: 'operationId') String? id,
      List<Parameter>? parameters,
      RequestBody? requestBody,
      Map<String, Response>? responses,
      @_ApiCallbackMapConverter() Map<String, ApiCallback>? callbacks,
      bool? deprecated,
      List<Security>? security,
      List<Server>? servers});

  @override
  $ExternalDocsCopyWith<$Res>? get externalDocs;
  @override
  $RequestBodyCopyWith<$Res>? get requestBody;
}

/// @nodoc
class __$$_OperationCopyWithImpl<$Res>
    extends _$OperationCopyWithImpl<$Res, _$_Operation>
    implements _$$_OperationCopyWith<$Res> {
  __$$_OperationCopyWithImpl(
      _$_Operation _value, $Res Function(_$_Operation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tags = freezed,
    Object? summary = freezed,
    Object? description = freezed,
    Object? externalDocs = freezed,
    Object? id = freezed,
    Object? parameters = freezed,
    Object? requestBody = freezed,
    Object? responses = freezed,
    Object? callbacks = freezed,
    Object? deprecated = freezed,
    Object? security = freezed,
    Object? servers = freezed,
  }) {
    return _then(_$_Operation(
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<Parameter>?,
      requestBody: freezed == requestBody
          ? _value.requestBody
          : requestBody // ignore: cast_nullable_to_non_nullable
              as RequestBody?,
      responses: freezed == responses
          ? _value._responses
          : responses // ignore: cast_nullable_to_non_nullable
              as Map<String, Response>?,
      callbacks: freezed == callbacks
          ? _value._callbacks
          : callbacks // ignore: cast_nullable_to_non_nullable
              as Map<String, ApiCallback>?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      security: freezed == security
          ? _value._security
          : security // ignore: cast_nullable_to_non_nullable
              as List<Security>?,
      servers: freezed == servers
          ? _value._servers
          : servers // ignore: cast_nullable_to_non_nullable
              as List<Server>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Operation implements _Operation {
  const _$_Operation(
      {final List<String>? tags,
      this.summary,
      this.description,
      this.externalDocs,
      @JsonKey(name: 'operationId') this.id,
      final List<Parameter>? parameters,
      this.requestBody,
      final Map<String, Response>? responses,
      @_ApiCallbackMapConverter() final Map<String, ApiCallback>? callbacks,
      this.deprecated,
      final List<Security>? security,
      final List<Server>? servers})
      : _tags = tags,
        _parameters = parameters,
        _responses = responses,
        _callbacks = callbacks,
        _security = security,
        _servers = servers;

  factory _$_Operation.fromJson(Map<String, dynamic> json) =>
      _$$_OperationFromJson(json);

  /// A list of tags for API documentation control.
  final List<String>? _tags;

  /// A list of tags for API documentation control.
  @override
  List<String>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A short summary of what the operation does.
  @override
  final String? summary;

  /// An optional string describing the host designated by the URL.
  @override
  final String? description;

  /// Additional external documentation for this schema.
  @override
  final ExternalDocs? externalDocs;

  /// Unique string used to identify the operation.
  /// The id MUST be unique among all operations described in the API.
  @override
  @JsonKey(name: 'operationId')
  final String? id;

  /// A list of parameters that are applicable for this operation.
  /// If a parameter is already defined at the [PathItem] level,
  /// the new definition will override it but can never remove it.
  final List<Parameter>? _parameters;

  /// A list of parameters that are applicable for this operation.
  /// If a parameter is already defined at the [PathItem] level,
  /// the new definition will override it but can never remove it.
  @override
  List<Parameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The request body applicable for this operation.
  @override
  final RequestBody? requestBody;

  /// The list of possible responses as they are returned from executing this operation.
  final Map<String, Response>? _responses;

  /// The list of possible responses as they are returned from executing this operation.
  @override
  Map<String, Response>? get responses {
    final value = _responses;
    if (value == null) return null;
    if (_responses is EqualUnmodifiableMapView) return _responses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A map of possible out-of band callbacks related to the parent operation.
  /// The key is a unique identifier for the [ApiCallback] Object.
  final Map<String, ApiCallback>? _callbacks;

  /// A map of possible out-of band callbacks related to the parent operation.
  /// The key is a unique identifier for the [ApiCallback] Object.
  @override
  @_ApiCallbackMapConverter()
  Map<String, ApiCallback>? get callbacks {
    final value = _callbacks;
    if (value == null) return null;
    if (_callbacks is EqualUnmodifiableMapView) return _callbacks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Declares this operation to be deprecated.
  @override
  final bool? deprecated;

  /// A declaration of which security mechanisms can be used for this operation.
  /// The list of values includes alternative security requirement objects that can be used.
  final List<Security>? _security;

  /// A declaration of which security mechanisms can be used for this operation.
  /// The list of values includes alternative security requirement objects that can be used.
  @override
  List<Security>? get security {
    final value = _security;
    if (value == null) return null;
    if (_security is EqualUnmodifiableListView) return _security;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// An alternative [Server] array to service this operation.
  /// If an alternative [Server] object is specified at the [PathItem] level,
  /// it will be overridden by this value.
  final List<Server>? _servers;

  /// An alternative [Server] array to service this operation.
  /// If an alternative [Server] object is specified at the [PathItem] level,
  /// it will be overridden by this value.
  @override
  List<Server>? get servers {
    final value = _servers;
    if (value == null) return null;
    if (_servers is EqualUnmodifiableListView) return _servers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Operation(tags: $tags, summary: $summary, description: $description, externalDocs: $externalDocs, id: $id, parameters: $parameters, requestBody: $requestBody, responses: $responses, callbacks: $callbacks, deprecated: $deprecated, security: $security, servers: $servers)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Operation &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.externalDocs, externalDocs) ||
                other.externalDocs == externalDocs) &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            (identical(other.requestBody, requestBody) ||
                other.requestBody == requestBody) &&
            const DeepCollectionEquality()
                .equals(other._responses, _responses) &&
            const DeepCollectionEquality()
                .equals(other._callbacks, _callbacks) &&
            (identical(other.deprecated, deprecated) ||
                other.deprecated == deprecated) &&
            const DeepCollectionEquality().equals(other._security, _security) &&
            const DeepCollectionEquality().equals(other._servers, _servers));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_tags),
      summary,
      description,
      externalDocs,
      id,
      const DeepCollectionEquality().hash(_parameters),
      requestBody,
      const DeepCollectionEquality().hash(_responses),
      const DeepCollectionEquality().hash(_callbacks),
      deprecated,
      const DeepCollectionEquality().hash(_security),
      const DeepCollectionEquality().hash(_servers));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OperationCopyWith<_$_Operation> get copyWith =>
      __$$_OperationCopyWithImpl<_$_Operation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OperationToJson(
      this,
    );
  }
}

abstract class _Operation implements Operation {
  const factory _Operation(
      {final List<String>? tags,
      final String? summary,
      final String? description,
      final ExternalDocs? externalDocs,
      @JsonKey(name: 'operationId') final String? id,
      final List<Parameter>? parameters,
      final RequestBody? requestBody,
      final Map<String, Response>? responses,
      @_ApiCallbackMapConverter() final Map<String, ApiCallback>? callbacks,
      final bool? deprecated,
      final List<Security>? security,
      final List<Server>? servers}) = _$_Operation;

  factory _Operation.fromJson(Map<String, dynamic> json) =
      _$_Operation.fromJson;

  @override

  /// A list of tags for API documentation control.
  List<String>? get tags;
  @override

  /// A short summary of what the operation does.
  String? get summary;
  @override

  /// An optional string describing the host designated by the URL.
  String? get description;
  @override

  /// Additional external documentation for this schema.
  ExternalDocs? get externalDocs;
  @override

  /// Unique string used to identify the operation.
  /// The id MUST be unique among all operations described in the API.
  @JsonKey(name: 'operationId')
  String? get id;
  @override

  /// A list of parameters that are applicable for this operation.
  /// If a parameter is already defined at the [PathItem] level,
  /// the new definition will override it but can never remove it.
  List<Parameter>? get parameters;
  @override

  /// The request body applicable for this operation.
  RequestBody? get requestBody;
  @override

  /// The list of possible responses as they are returned from executing this operation.
  Map<String, Response>? get responses;
  @override

  /// A map of possible out-of band callbacks related to the parent operation.
  /// The key is a unique identifier for the [ApiCallback] Object.
  @_ApiCallbackMapConverter()
  Map<String, ApiCallback>? get callbacks;
  @override

  /// Declares this operation to be deprecated.
  bool? get deprecated;
  @override

  /// A declaration of which security mechanisms can be used for this operation.
  /// The list of values includes alternative security requirement objects that can be used.
  List<Security>? get security;
  @override

  /// An alternative [Server] array to service this operation.
  /// If an alternative [Server] object is specified at the [PathItem] level,
  /// it will be overridden by this value.
  List<Server>? get servers;
  @override
  @JsonKey(ignore: true)
  _$$_OperationCopyWith<_$_Operation> get copyWith =>
      throw _privateConstructorUsedError;
}

Parameter _$ParameterFromJson(Map<String, dynamic> json) {
  switch (json['in']) {
    case 'cookie':
      return _ParameterCookie.fromJson(json);
    case 'header':
      return _ParameterHeader.fromJson(json);
    case 'query':
      return _ParameterQuery.fromJson(json);
    case 'path':
      return _ParameterPath.fromJson(json);

    default:
      throw CheckedFromJsonException(
          json, 'in', 'Parameter', 'Invalid union type "${json['in']}"!');
  }
}

/// @nodoc
mixin _$Parameter {
  String? get name => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  bool? get deprecated => throw _privateConstructorUsedError;
  String? get style => throw _privateConstructorUsedError;
  bool? get explode => throw _privateConstructorUsedError;
  bool? get allowReserved => throw _privateConstructorUsedError;
  String? get example => throw _privateConstructorUsedError;
  Schema? get schema => throw _privateConstructorUsedError;
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  String? get ref => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        cookie,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        header,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        query,
    required TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        path,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult? Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ParameterCookie value) cookie,
    required TResult Function(_ParameterHeader value) header,
    required TResult Function(_ParameterQuery value) query,
    required TResult Function(_ParameterPath value) path,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ParameterCookie value)? cookie,
    TResult? Function(_ParameterHeader value)? header,
    TResult? Function(_ParameterQuery value)? query,
    TResult? Function(_ParameterPath value)? path,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ParameterCookie value)? cookie,
    TResult Function(_ParameterHeader value)? header,
    TResult Function(_ParameterQuery value)? query,
    TResult Function(_ParameterPath value)? path,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ParameterCopyWith<Parameter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParameterCopyWith<$Res> {
  factory $ParameterCopyWith(Parameter value, $Res Function(Parameter) then) =
      _$ParameterCopyWithImpl<$Res, Parameter>;
  @useResult
  $Res call(
      {String? name,
      String? description,
      bool? deprecated,
      String? style,
      bool? explode,
      bool? allowReserved,
      String? example,
      Schema? schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref});

  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class _$ParameterCopyWithImpl<$Res, $Val extends Parameter>
    implements $ParameterCopyWith<$Res> {
  _$ParameterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? description = freezed,
    Object? deprecated = freezed,
    Object? style = freezed,
    Object? explode = freezed,
    Object? allowReserved = freezed,
    Object? example = freezed,
    Object? schema = freezed,
    Object? ref = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as String?,
      explode: freezed == explode
          ? _value.explode
          : explode // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowReserved: freezed == allowReserved
          ? _value.allowReserved
          : allowReserved // ignore: cast_nullable_to_non_nullable
              as bool?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $SchemaCopyWith<$Res>? get schema {
    if (_value.schema == null) {
      return null;
    }

    return $SchemaCopyWith<$Res>(_value.schema!, (value) {
      return _then(_value.copyWith(schema: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ParameterCookieCopyWith<$Res>
    implements $ParameterCopyWith<$Res> {
  factory _$$_ParameterCookieCopyWith(
          _$_ParameterCookie value, $Res Function(_$_ParameterCookie) then) =
      __$$_ParameterCookieCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? description,
      bool? required,
      bool? deprecated,
      String? style,
      bool? explode,
      bool? allowReserved,
      String? example,
      Schema? schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref});

  @override
  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class __$$_ParameterCookieCopyWithImpl<$Res>
    extends _$ParameterCopyWithImpl<$Res, _$_ParameterCookie>
    implements _$$_ParameterCookieCopyWith<$Res> {
  __$$_ParameterCookieCopyWithImpl(
      _$_ParameterCookie _value, $Res Function(_$_ParameterCookie) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? description = freezed,
    Object? required = freezed,
    Object? deprecated = freezed,
    Object? style = freezed,
    Object? explode = freezed,
    Object? allowReserved = freezed,
    Object? example = freezed,
    Object? schema = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_ParameterCookie(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as String?,
      explode: freezed == explode
          ? _value.explode
          : explode // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowReserved: freezed == allowReserved
          ? _value.allowReserved
          : allowReserved // ignore: cast_nullable_to_non_nullable
              as bool?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ParameterCookie extends _ParameterCookie {
  const _$_ParameterCookie(
      {this.name,
      this.description,
      this.required,
      this.deprecated,
      this.style,
      this.explode,
      this.allowReserved,
      this.example,
      this.schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() this.ref,
      final String? $type})
      : assert((name == null && ref == null) == false,
            'Must provide either name or ref'),
        assert((name != null && ref != null) == false,
            'Must provide either name or ref, not both'),
        $type = $type ?? 'cookie',
        super._();

  factory _$_ParameterCookie.fromJson(Map<String, dynamic> json) =>
      _$$_ParameterCookieFromJson(json);

  @override
  final String? name;
  @override
  final String? description;
  @override
  final bool? required;
  @override
  final bool? deprecated;
  @override
  final String? style;
  @override
  final bool? explode;
  @override
  final bool? allowReserved;
  @override
  final String? example;
  @override
  final Schema? schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  final String? ref;

  @JsonKey(name: 'in')
  final String $type;

  @override
  String toString() {
    return 'Parameter.cookie(name: $name, description: $description, required: $required, deprecated: $deprecated, style: $style, explode: $explode, allowReserved: $allowReserved, example: $example, schema: $schema, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ParameterCookie &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.required, required) ||
                other.required == required) &&
            (identical(other.deprecated, deprecated) ||
                other.deprecated == deprecated) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.explode, explode) || other.explode == explode) &&
            (identical(other.allowReserved, allowReserved) ||
                other.allowReserved == allowReserved) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.schema, schema) || other.schema == schema) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description, required,
      deprecated, style, explode, allowReserved, example, schema, ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ParameterCookieCopyWith<_$_ParameterCookie> get copyWith =>
      __$$_ParameterCookieCopyWithImpl<_$_ParameterCookie>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        cookie,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        header,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        query,
    required TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        path,
  }) {
    return cookie(name, description, required, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult? Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
  }) {
    return cookie?.call(name, description, required, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
    required TResult orElse(),
  }) {
    if (cookie != null) {
      return cookie(name, description, required, deprecated, style, explode,
          allowReserved, example, schema, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ParameterCookie value) cookie,
    required TResult Function(_ParameterHeader value) header,
    required TResult Function(_ParameterQuery value) query,
    required TResult Function(_ParameterPath value) path,
  }) {
    return cookie(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ParameterCookie value)? cookie,
    TResult? Function(_ParameterHeader value)? header,
    TResult? Function(_ParameterQuery value)? query,
    TResult? Function(_ParameterPath value)? path,
  }) {
    return cookie?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ParameterCookie value)? cookie,
    TResult Function(_ParameterHeader value)? header,
    TResult Function(_ParameterQuery value)? query,
    TResult Function(_ParameterPath value)? path,
    required TResult orElse(),
  }) {
    if (cookie != null) {
      return cookie(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParameterCookieToJson(
      this,
    );
  }
}

abstract class _ParameterCookie extends Parameter {
  const factory _ParameterCookie(
          {final String? name,
          final String? description,
          final bool? required,
          final bool? deprecated,
          final String? style,
          final bool? explode,
          final bool? allowReserved,
          final String? example,
          final Schema? schema,
          @JsonKey(name: '\$ref') @_ParamRefConverter() final String? ref}) =
      _$_ParameterCookie;
  const _ParameterCookie._() : super._();

  factory _ParameterCookie.fromJson(Map<String, dynamic> json) =
      _$_ParameterCookie.fromJson;

  @override
  String? get name;
  @override
  String? get description;
  bool? get required;
  @override
  bool? get deprecated;
  @override
  String? get style;
  @override
  bool? get explode;
  @override
  bool? get allowReserved;
  @override
  String? get example;
  @override
  Schema? get schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_ParameterCookieCopyWith<_$_ParameterCookie> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ParameterHeaderCopyWith<$Res>
    implements $ParameterCopyWith<$Res> {
  factory _$$_ParameterHeaderCopyWith(
          _$_ParameterHeader value, $Res Function(_$_ParameterHeader) then) =
      __$$_ParameterHeaderCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? description,
      bool? required,
      bool? deprecated,
      String? style,
      bool? explode,
      bool? allowReserved,
      String? example,
      Schema? schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref});

  @override
  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class __$$_ParameterHeaderCopyWithImpl<$Res>
    extends _$ParameterCopyWithImpl<$Res, _$_ParameterHeader>
    implements _$$_ParameterHeaderCopyWith<$Res> {
  __$$_ParameterHeaderCopyWithImpl(
      _$_ParameterHeader _value, $Res Function(_$_ParameterHeader) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? description = freezed,
    Object? required = freezed,
    Object? deprecated = freezed,
    Object? style = freezed,
    Object? explode = freezed,
    Object? allowReserved = freezed,
    Object? example = freezed,
    Object? schema = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_ParameterHeader(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as String?,
      explode: freezed == explode
          ? _value.explode
          : explode // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowReserved: freezed == allowReserved
          ? _value.allowReserved
          : allowReserved // ignore: cast_nullable_to_non_nullable
              as bool?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ParameterHeader extends _ParameterHeader {
  const _$_ParameterHeader(
      {this.name,
      this.description,
      this.required,
      this.deprecated,
      this.style,
      this.explode,
      this.allowReserved,
      this.example,
      this.schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() this.ref,
      final String? $type})
      : assert((name == null && ref == null) == false,
            'Must provide either name or ref'),
        assert((name != null && ref != null) == false,
            'Must provide either name or ref, not both'),
        $type = $type ?? 'header',
        super._();

  factory _$_ParameterHeader.fromJson(Map<String, dynamic> json) =>
      _$$_ParameterHeaderFromJson(json);

  @override
  final String? name;
  @override
  final String? description;
  @override
  final bool? required;
  @override
  final bool? deprecated;
  @override
  final String? style;
  @override
  final bool? explode;
  @override
  final bool? allowReserved;
  @override
  final String? example;
  @override
  final Schema? schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  final String? ref;

  @JsonKey(name: 'in')
  final String $type;

  @override
  String toString() {
    return 'Parameter.header(name: $name, description: $description, required: $required, deprecated: $deprecated, style: $style, explode: $explode, allowReserved: $allowReserved, example: $example, schema: $schema, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ParameterHeader &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.required, required) ||
                other.required == required) &&
            (identical(other.deprecated, deprecated) ||
                other.deprecated == deprecated) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.explode, explode) || other.explode == explode) &&
            (identical(other.allowReserved, allowReserved) ||
                other.allowReserved == allowReserved) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.schema, schema) || other.schema == schema) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description, required,
      deprecated, style, explode, allowReserved, example, schema, ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ParameterHeaderCopyWith<_$_ParameterHeader> get copyWith =>
      __$$_ParameterHeaderCopyWithImpl<_$_ParameterHeader>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        cookie,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        header,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        query,
    required TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        path,
  }) {
    return header(name, description, required, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult? Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
  }) {
    return header?.call(name, description, required, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
    required TResult orElse(),
  }) {
    if (header != null) {
      return header(name, description, required, deprecated, style, explode,
          allowReserved, example, schema, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ParameterCookie value) cookie,
    required TResult Function(_ParameterHeader value) header,
    required TResult Function(_ParameterQuery value) query,
    required TResult Function(_ParameterPath value) path,
  }) {
    return header(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ParameterCookie value)? cookie,
    TResult? Function(_ParameterHeader value)? header,
    TResult? Function(_ParameterQuery value)? query,
    TResult? Function(_ParameterPath value)? path,
  }) {
    return header?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ParameterCookie value)? cookie,
    TResult Function(_ParameterHeader value)? header,
    TResult Function(_ParameterQuery value)? query,
    TResult Function(_ParameterPath value)? path,
    required TResult orElse(),
  }) {
    if (header != null) {
      return header(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParameterHeaderToJson(
      this,
    );
  }
}

abstract class _ParameterHeader extends Parameter {
  const factory _ParameterHeader(
          {final String? name,
          final String? description,
          final bool? required,
          final bool? deprecated,
          final String? style,
          final bool? explode,
          final bool? allowReserved,
          final String? example,
          final Schema? schema,
          @JsonKey(name: '\$ref') @_ParamRefConverter() final String? ref}) =
      _$_ParameterHeader;
  const _ParameterHeader._() : super._();

  factory _ParameterHeader.fromJson(Map<String, dynamic> json) =
      _$_ParameterHeader.fromJson;

  @override
  String? get name;
  @override
  String? get description;
  bool? get required;
  @override
  bool? get deprecated;
  @override
  String? get style;
  @override
  bool? get explode;
  @override
  bool? get allowReserved;
  @override
  String? get example;
  @override
  Schema? get schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_ParameterHeaderCopyWith<_$_ParameterHeader> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ParameterQueryCopyWith<$Res>
    implements $ParameterCopyWith<$Res> {
  factory _$$_ParameterQueryCopyWith(
          _$_ParameterQuery value, $Res Function(_$_ParameterQuery) then) =
      __$$_ParameterQueryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? description,
      bool? required,
      bool? deprecated,
      String? style,
      bool? explode,
      bool? allowReserved,
      String? example,
      Schema? schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref});

  @override
  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class __$$_ParameterQueryCopyWithImpl<$Res>
    extends _$ParameterCopyWithImpl<$Res, _$_ParameterQuery>
    implements _$$_ParameterQueryCopyWith<$Res> {
  __$$_ParameterQueryCopyWithImpl(
      _$_ParameterQuery _value, $Res Function(_$_ParameterQuery) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? description = freezed,
    Object? required = freezed,
    Object? deprecated = freezed,
    Object? style = freezed,
    Object? explode = freezed,
    Object? allowReserved = freezed,
    Object? example = freezed,
    Object? schema = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_ParameterQuery(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as String?,
      explode: freezed == explode
          ? _value.explode
          : explode // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowReserved: freezed == allowReserved
          ? _value.allowReserved
          : allowReserved // ignore: cast_nullable_to_non_nullable
              as bool?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ParameterQuery extends _ParameterQuery {
  const _$_ParameterQuery(
      {this.name,
      this.description,
      this.required,
      this.deprecated,
      this.style,
      this.explode,
      this.allowReserved,
      this.example,
      this.schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() this.ref,
      final String? $type})
      : assert((name == null && ref == null) == false,
            'Must provide either name or ref'),
        assert((name != null && ref != null) == false,
            'Must provide either name or ref, not both'),
        $type = $type ?? 'query',
        super._();

  factory _$_ParameterQuery.fromJson(Map<String, dynamic> json) =>
      _$$_ParameterQueryFromJson(json);

  @override
  final String? name;
  @override
  final String? description;
  @override
  final bool? required;
  @override
  final bool? deprecated;
  @override
  final String? style;
  @override
  final bool? explode;
  @override
  final bool? allowReserved;
  @override
  final String? example;
  @override
  final Schema? schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  final String? ref;

  @JsonKey(name: 'in')
  final String $type;

  @override
  String toString() {
    return 'Parameter.query(name: $name, description: $description, required: $required, deprecated: $deprecated, style: $style, explode: $explode, allowReserved: $allowReserved, example: $example, schema: $schema, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ParameterQuery &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.required, required) ||
                other.required == required) &&
            (identical(other.deprecated, deprecated) ||
                other.deprecated == deprecated) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.explode, explode) || other.explode == explode) &&
            (identical(other.allowReserved, allowReserved) ||
                other.allowReserved == allowReserved) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.schema, schema) || other.schema == schema) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description, required,
      deprecated, style, explode, allowReserved, example, schema, ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ParameterQueryCopyWith<_$_ParameterQuery> get copyWith =>
      __$$_ParameterQueryCopyWithImpl<_$_ParameterQuery>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        cookie,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        header,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        query,
    required TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        path,
  }) {
    return query(name, description, required, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult? Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
  }) {
    return query?.call(name, description, required, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
    required TResult orElse(),
  }) {
    if (query != null) {
      return query(name, description, required, deprecated, style, explode,
          allowReserved, example, schema, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ParameterCookie value) cookie,
    required TResult Function(_ParameterHeader value) header,
    required TResult Function(_ParameterQuery value) query,
    required TResult Function(_ParameterPath value) path,
  }) {
    return query(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ParameterCookie value)? cookie,
    TResult? Function(_ParameterHeader value)? header,
    TResult? Function(_ParameterQuery value)? query,
    TResult? Function(_ParameterPath value)? path,
  }) {
    return query?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ParameterCookie value)? cookie,
    TResult Function(_ParameterHeader value)? header,
    TResult Function(_ParameterQuery value)? query,
    TResult Function(_ParameterPath value)? path,
    required TResult orElse(),
  }) {
    if (query != null) {
      return query(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParameterQueryToJson(
      this,
    );
  }
}

abstract class _ParameterQuery extends Parameter {
  const factory _ParameterQuery(
          {final String? name,
          final String? description,
          final bool? required,
          final bool? deprecated,
          final String? style,
          final bool? explode,
          final bool? allowReserved,
          final String? example,
          final Schema? schema,
          @JsonKey(name: '\$ref') @_ParamRefConverter() final String? ref}) =
      _$_ParameterQuery;
  const _ParameterQuery._() : super._();

  factory _ParameterQuery.fromJson(Map<String, dynamic> json) =
      _$_ParameterQuery.fromJson;

  @override
  String? get name;
  @override
  String? get description;
  bool? get required;
  @override
  bool? get deprecated;
  @override
  String? get style;
  @override
  bool? get explode;
  @override
  bool? get allowReserved;
  @override
  String? get example;
  @override
  Schema? get schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_ParameterQueryCopyWith<_$_ParameterQuery> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ParameterPathCopyWith<$Res>
    implements $ParameterCopyWith<$Res> {
  factory _$$_ParameterPathCopyWith(
          _$_ParameterPath value, $Res Function(_$_ParameterPath) then) =
      __$$_ParameterPathCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? description,
      bool? deprecated,
      String? style,
      bool? explode,
      bool? allowReserved,
      String? example,
      Schema? schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref});

  @override
  $SchemaCopyWith<$Res>? get schema;
}

/// @nodoc
class __$$_ParameterPathCopyWithImpl<$Res>
    extends _$ParameterCopyWithImpl<$Res, _$_ParameterPath>
    implements _$$_ParameterPathCopyWith<$Res> {
  __$$_ParameterPathCopyWithImpl(
      _$_ParameterPath _value, $Res Function(_$_ParameterPath) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? description = freezed,
    Object? deprecated = freezed,
    Object? style = freezed,
    Object? explode = freezed,
    Object? allowReserved = freezed,
    Object? example = freezed,
    Object? schema = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_ParameterPath(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      deprecated: freezed == deprecated
          ? _value.deprecated
          : deprecated // ignore: cast_nullable_to_non_nullable
              as bool?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as String?,
      explode: freezed == explode
          ? _value.explode
          : explode // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowReserved: freezed == allowReserved
          ? _value.allowReserved
          : allowReserved // ignore: cast_nullable_to_non_nullable
              as bool?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ParameterPath extends _ParameterPath {
  const _$_ParameterPath(
      {this.name,
      this.description,
      this.deprecated,
      this.style,
      this.explode,
      this.allowReserved,
      this.example,
      this.schema,
      @JsonKey(name: '\$ref') @_ParamRefConverter() this.ref,
      final String? $type})
      : assert((name == null && ref == null) == false,
            'Must provide either name or ref'),
        assert((name != null && ref != null) == false,
            'Must provide either name or ref, not both'),
        $type = $type ?? 'path',
        super._();

  factory _$_ParameterPath.fromJson(Map<String, dynamic> json) =>
      _$$_ParameterPathFromJson(json);

  @override
  final String? name;
  @override
  final String? description;
  @override
  final bool? deprecated;
  @override
  final String? style;
  @override
  final bool? explode;
  @override
  final bool? allowReserved;
  @override
  final String? example;
  @override
  final Schema? schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  final String? ref;

  @JsonKey(name: 'in')
  final String $type;

  @override
  String toString() {
    return 'Parameter.path(name: $name, description: $description, deprecated: $deprecated, style: $style, explode: $explode, allowReserved: $allowReserved, example: $example, schema: $schema, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ParameterPath &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.deprecated, deprecated) ||
                other.deprecated == deprecated) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.explode, explode) || other.explode == explode) &&
            (identical(other.allowReserved, allowReserved) ||
                other.allowReserved == allowReserved) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.schema, schema) || other.schema == schema) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description, deprecated,
      style, explode, allowReserved, example, schema, ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ParameterPathCopyWith<_$_ParameterPath> get copyWith =>
      __$$_ParameterPathCopyWithImpl<_$_ParameterPath>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        cookie,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        header,
    required TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        query,
    required TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)
        path,
  }) {
    return path(name, description, deprecated, style, explode, allowReserved,
        example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult? Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult? Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
  }) {
    return path?.call(name, description, deprecated, style, explode,
        allowReserved, example, schema, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        cookie,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        header,
    TResult Function(
            String? name,
            String? description,
            bool? required,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        query,
    TResult Function(
            String? name,
            String? description,
            bool? deprecated,
            String? style,
            bool? explode,
            bool? allowReserved,
            String? example,
            Schema? schema,
            @JsonKey(name: '\$ref') @_ParamRefConverter() String? ref)?
        path,
    required TResult orElse(),
  }) {
    if (path != null) {
      return path(name, description, deprecated, style, explode, allowReserved,
          example, schema, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ParameterCookie value) cookie,
    required TResult Function(_ParameterHeader value) header,
    required TResult Function(_ParameterQuery value) query,
    required TResult Function(_ParameterPath value) path,
  }) {
    return path(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ParameterCookie value)? cookie,
    TResult? Function(_ParameterHeader value)? header,
    TResult? Function(_ParameterQuery value)? query,
    TResult? Function(_ParameterPath value)? path,
  }) {
    return path?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ParameterCookie value)? cookie,
    TResult Function(_ParameterHeader value)? header,
    TResult Function(_ParameterQuery value)? query,
    TResult Function(_ParameterPath value)? path,
    required TResult orElse(),
  }) {
    if (path != null) {
      return path(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParameterPathToJson(
      this,
    );
  }
}

abstract class _ParameterPath extends Parameter {
  const factory _ParameterPath(
          {final String? name,
          final String? description,
          final bool? deprecated,
          final String? style,
          final bool? explode,
          final bool? allowReserved,
          final String? example,
          final Schema? schema,
          @JsonKey(name: '\$ref') @_ParamRefConverter() final String? ref}) =
      _$_ParameterPath;
  const _ParameterPath._() : super._();

  factory _ParameterPath.fromJson(Map<String, dynamic> json) =
      _$_ParameterPath.fromJson;

  @override
  String? get name;
  @override
  String? get description;
  @override
  bool? get deprecated;
  @override
  String? get style;
  @override
  bool? get explode;
  @override
  bool? get allowReserved;
  @override
  String? get example;
  @override
  Schema? get schema;
  @override
  @JsonKey(name: '\$ref')
  @_ParamRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_ParameterPathCopyWith<_$_ParameterPath> get copyWith =>
      throw _privateConstructorUsedError;
}

PathItem _$PathItemFromJson(Map<String, dynamic> json) {
  return _PathItem.fromJson(json);
}

/// @nodoc
mixin _$PathItem {
  /// An optional, string summary, intended to apply to all operations in this Path.
  String? get summary => throw _privateConstructorUsedError;

  /// An optional, string description, intended to apply to all operations in this Path.
  String? get description => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get get => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get put => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get post => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get delete => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get options => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get head => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get patch => throw _privateConstructorUsedError;

  /// A definition of a GET operation on this Path.
  Operation? get trace => throw _privateConstructorUsedError;

  /// An alternative [Server] array to service all operations in this Path.
  List<Server>? get servers => throw _privateConstructorUsedError;

  /// A list of parameters that are applicable for all the operations described under this Path.
  /// These parameters can be overridden at the operation level, but cannot be removed there.
  List<Parameter>? get parameters => throw _privateConstructorUsedError;

  /// Reference to a response defined in [Components.pathItems]
  @JsonKey(name: '\$ref')
  @_PathRefConverter()
  String? get ref => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PathItemCopyWith<PathItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PathItemCopyWith<$Res> {
  factory $PathItemCopyWith(PathItem value, $Res Function(PathItem) then) =
      _$PathItemCopyWithImpl<$Res, PathItem>;
  @useResult
  $Res call(
      {String? summary,
      String? description,
      Operation? get,
      Operation? put,
      Operation? post,
      Operation? delete,
      Operation? options,
      Operation? head,
      Operation? patch,
      Operation? trace,
      List<Server>? servers,
      List<Parameter>? parameters,
      @JsonKey(name: '\$ref') @_PathRefConverter() String? ref});

  $OperationCopyWith<$Res>? get get;
  $OperationCopyWith<$Res>? get put;
  $OperationCopyWith<$Res>? get post;
  $OperationCopyWith<$Res>? get delete;
  $OperationCopyWith<$Res>? get options;
  $OperationCopyWith<$Res>? get head;
  $OperationCopyWith<$Res>? get patch;
  $OperationCopyWith<$Res>? get trace;
}

/// @nodoc
class _$PathItemCopyWithImpl<$Res, $Val extends PathItem>
    implements $PathItemCopyWith<$Res> {
  _$PathItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? description = freezed,
    Object? get = freezed,
    Object? put = freezed,
    Object? post = freezed,
    Object? delete = freezed,
    Object? options = freezed,
    Object? head = freezed,
    Object? patch = freezed,
    Object? trace = freezed,
    Object? servers = freezed,
    Object? parameters = freezed,
    Object? ref = freezed,
  }) {
    return _then(_value.copyWith(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      get: freezed == get
          ? _value.get
          : get // ignore: cast_nullable_to_non_nullable
              as Operation?,
      put: freezed == put
          ? _value.put
          : put // ignore: cast_nullable_to_non_nullable
              as Operation?,
      post: freezed == post
          ? _value.post
          : post // ignore: cast_nullable_to_non_nullable
              as Operation?,
      delete: freezed == delete
          ? _value.delete
          : delete // ignore: cast_nullable_to_non_nullable
              as Operation?,
      options: freezed == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as Operation?,
      head: freezed == head
          ? _value.head
          : head // ignore: cast_nullable_to_non_nullable
              as Operation?,
      patch: freezed == patch
          ? _value.patch
          : patch // ignore: cast_nullable_to_non_nullable
              as Operation?,
      trace: freezed == trace
          ? _value.trace
          : trace // ignore: cast_nullable_to_non_nullable
              as Operation?,
      servers: freezed == servers
          ? _value.servers
          : servers // ignore: cast_nullable_to_non_nullable
              as List<Server>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<Parameter>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get get {
    if (_value.get == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.get!, (value) {
      return _then(_value.copyWith(get: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get put {
    if (_value.put == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.put!, (value) {
      return _then(_value.copyWith(put: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get post {
    if (_value.post == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.post!, (value) {
      return _then(_value.copyWith(post: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get delete {
    if (_value.delete == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.delete!, (value) {
      return _then(_value.copyWith(delete: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get options {
    if (_value.options == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.options!, (value) {
      return _then(_value.copyWith(options: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get head {
    if (_value.head == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.head!, (value) {
      return _then(_value.copyWith(head: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get patch {
    if (_value.patch == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.patch!, (value) {
      return _then(_value.copyWith(patch: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get trace {
    if (_value.trace == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.trace!, (value) {
      return _then(_value.copyWith(trace: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_PathItemCopyWith<$Res> implements $PathItemCopyWith<$Res> {
  factory _$$_PathItemCopyWith(
          _$_PathItem value, $Res Function(_$_PathItem) then) =
      __$$_PathItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? summary,
      String? description,
      Operation? get,
      Operation? put,
      Operation? post,
      Operation? delete,
      Operation? options,
      Operation? head,
      Operation? patch,
      Operation? trace,
      List<Server>? servers,
      List<Parameter>? parameters,
      @JsonKey(name: '\$ref') @_PathRefConverter() String? ref});

  @override
  $OperationCopyWith<$Res>? get get;
  @override
  $OperationCopyWith<$Res>? get put;
  @override
  $OperationCopyWith<$Res>? get post;
  @override
  $OperationCopyWith<$Res>? get delete;
  @override
  $OperationCopyWith<$Res>? get options;
  @override
  $OperationCopyWith<$Res>? get head;
  @override
  $OperationCopyWith<$Res>? get patch;
  @override
  $OperationCopyWith<$Res>? get trace;
}

/// @nodoc
class __$$_PathItemCopyWithImpl<$Res>
    extends _$PathItemCopyWithImpl<$Res, _$_PathItem>
    implements _$$_PathItemCopyWith<$Res> {
  __$$_PathItemCopyWithImpl(
      _$_PathItem _value, $Res Function(_$_PathItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? summary = freezed,
    Object? description = freezed,
    Object? get = freezed,
    Object? put = freezed,
    Object? post = freezed,
    Object? delete = freezed,
    Object? options = freezed,
    Object? head = freezed,
    Object? patch = freezed,
    Object? trace = freezed,
    Object? servers = freezed,
    Object? parameters = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_PathItem(
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      get: freezed == get
          ? _value.get
          : get // ignore: cast_nullable_to_non_nullable
              as Operation?,
      put: freezed == put
          ? _value.put
          : put // ignore: cast_nullable_to_non_nullable
              as Operation?,
      post: freezed == post
          ? _value.post
          : post // ignore: cast_nullable_to_non_nullable
              as Operation?,
      delete: freezed == delete
          ? _value.delete
          : delete // ignore: cast_nullable_to_non_nullable
              as Operation?,
      options: freezed == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as Operation?,
      head: freezed == head
          ? _value.head
          : head // ignore: cast_nullable_to_non_nullable
              as Operation?,
      patch: freezed == patch
          ? _value.patch
          : patch // ignore: cast_nullable_to_non_nullable
              as Operation?,
      trace: freezed == trace
          ? _value.trace
          : trace // ignore: cast_nullable_to_non_nullable
              as Operation?,
      servers: freezed == servers
          ? _value._servers
          : servers // ignore: cast_nullable_to_non_nullable
              as List<Server>?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<Parameter>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PathItem extends _PathItem {
  const _$_PathItem(
      {this.summary,
      this.description,
      this.get,
      this.put,
      this.post,
      this.delete,
      this.options,
      this.head,
      this.patch,
      this.trace,
      final List<Server>? servers,
      final List<Parameter>? parameters,
      @JsonKey(name: '\$ref') @_PathRefConverter() this.ref})
      : _servers = servers,
        _parameters = parameters,
        super._();

  factory _$_PathItem.fromJson(Map<String, dynamic> json) =>
      _$$_PathItemFromJson(json);

  /// An optional, string summary, intended to apply to all operations in this Path.
  @override
  final String? summary;

  /// An optional, string description, intended to apply to all operations in this Path.
  @override
  final String? description;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? get;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? put;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? post;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? delete;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? options;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? head;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? patch;

  /// A definition of a GET operation on this Path.
  @override
  final Operation? trace;

  /// An alternative [Server] array to service all operations in this Path.
  final List<Server>? _servers;

  /// An alternative [Server] array to service all operations in this Path.
  @override
  List<Server>? get servers {
    final value = _servers;
    if (value == null) return null;
    if (_servers is EqualUnmodifiableListView) return _servers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A list of parameters that are applicable for all the operations described under this Path.
  /// These parameters can be overridden at the operation level, but cannot be removed there.
  final List<Parameter>? _parameters;

  /// A list of parameters that are applicable for all the operations described under this Path.
  /// These parameters can be overridden at the operation level, but cannot be removed there.
  @override
  List<Parameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Reference to a response defined in [Components.pathItems]
  @override
  @JsonKey(name: '\$ref')
  @_PathRefConverter()
  final String? ref;

  @override
  String toString() {
    return 'PathItem(summary: $summary, description: $description, get: $get, put: $put, post: $post, delete: $delete, options: $options, head: $head, patch: $patch, trace: $trace, servers: $servers, parameters: $parameters, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PathItem &&
            (identical(other.summary, summary) || other.summary == summary) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.get, get) || other.get == get) &&
            (identical(other.put, put) || other.put == put) &&
            (identical(other.post, post) || other.post == post) &&
            (identical(other.delete, delete) || other.delete == delete) &&
            (identical(other.options, options) || other.options == options) &&
            (identical(other.head, head) || other.head == head) &&
            (identical(other.patch, patch) || other.patch == patch) &&
            (identical(other.trace, trace) || other.trace == trace) &&
            const DeepCollectionEquality().equals(other._servers, _servers) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      summary,
      description,
      get,
      put,
      post,
      delete,
      options,
      head,
      patch,
      trace,
      const DeepCollectionEquality().hash(_servers),
      const DeepCollectionEquality().hash(_parameters),
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PathItemCopyWith<_$_PathItem> get copyWith =>
      __$$_PathItemCopyWithImpl<_$_PathItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PathItemToJson(
      this,
    );
  }
}

abstract class _PathItem extends PathItem {
  const factory _PathItem(
          {final String? summary,
          final String? description,
          final Operation? get,
          final Operation? put,
          final Operation? post,
          final Operation? delete,
          final Operation? options,
          final Operation? head,
          final Operation? patch,
          final Operation? trace,
          final List<Server>? servers,
          final List<Parameter>? parameters,
          @JsonKey(name: '\$ref') @_PathRefConverter() final String? ref}) =
      _$_PathItem;
  const _PathItem._() : super._();

  factory _PathItem.fromJson(Map<String, dynamic> json) = _$_PathItem.fromJson;

  @override

  /// An optional, string summary, intended to apply to all operations in this Path.
  String? get summary;
  @override

  /// An optional, string description, intended to apply to all operations in this Path.
  String? get description;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get get;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get put;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get post;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get delete;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get options;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get head;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get patch;
  @override

  /// A definition of a GET operation on this Path.
  Operation? get trace;
  @override

  /// An alternative [Server] array to service all operations in this Path.
  List<Server>? get servers;
  @override

  /// A list of parameters that are applicable for all the operations described under this Path.
  /// These parameters can be overridden at the operation level, but cannot be removed there.
  List<Parameter>? get parameters;
  @override

  /// Reference to a response defined in [Components.pathItems]
  @JsonKey(name: '\$ref')
  @_PathRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_PathItemCopyWith<_$_PathItem> get copyWith =>
      throw _privateConstructorUsedError;
}

RequestBody _$RequestBodyFromJson(Map<String, dynamic> json) {
  return _RequestBody.fromJson(json);
}

/// @nodoc
mixin _$RequestBody {
  /// A brief description of the request body.
  String? get description => throw _privateConstructorUsedError;

  /// Determines if the request body is required in the request.
  bool? get required => throw _privateConstructorUsedError;

  /// The content of the request body.
  Map<String, MediaType>? get content => throw _privateConstructorUsedError;

  /// Reference to a response defined in [Components.requestBodies]
  @JsonKey(name: '\$ref')
  @_RequestRefConverter()
  String? get ref => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RequestBodyCopyWith<RequestBody> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequestBodyCopyWith<$Res> {
  factory $RequestBodyCopyWith(
          RequestBody value, $Res Function(RequestBody) then) =
      _$RequestBodyCopyWithImpl<$Res, RequestBody>;
  @useResult
  $Res call(
      {String? description,
      bool? required,
      Map<String, MediaType>? content,
      @JsonKey(name: '\$ref') @_RequestRefConverter() String? ref});
}

/// @nodoc
class _$RequestBodyCopyWithImpl<$Res, $Val extends RequestBody>
    implements $RequestBodyCopyWith<$Res> {
  _$RequestBodyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? required = freezed,
    Object? content = freezed,
    Object? ref = freezed,
  }) {
    return _then(_value.copyWith(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as Map<String, MediaType>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_RequestBodyCopyWith<$Res>
    implements $RequestBodyCopyWith<$Res> {
  factory _$$_RequestBodyCopyWith(
          _$_RequestBody value, $Res Function(_$_RequestBody) then) =
      __$$_RequestBodyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? description,
      bool? required,
      Map<String, MediaType>? content,
      @JsonKey(name: '\$ref') @_RequestRefConverter() String? ref});
}

/// @nodoc
class __$$_RequestBodyCopyWithImpl<$Res>
    extends _$RequestBodyCopyWithImpl<$Res, _$_RequestBody>
    implements _$$_RequestBodyCopyWith<$Res> {
  __$$_RequestBodyCopyWithImpl(
      _$_RequestBody _value, $Res Function(_$_RequestBody) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? required = freezed,
    Object? content = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_RequestBody(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as Map<String, MediaType>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RequestBody extends _RequestBody {
  const _$_RequestBody(
      {this.description,
      this.required,
      final Map<String, MediaType>? content,
      @JsonKey(name: '\$ref') @_RequestRefConverter() this.ref})
      : _content = content,
        super._();

  factory _$_RequestBody.fromJson(Map<String, dynamic> json) =>
      _$$_RequestBodyFromJson(json);

  /// A brief description of the request body.
  @override
  final String? description;

  /// Determines if the request body is required in the request.
  @override
  final bool? required;

  /// The content of the request body.
  final Map<String, MediaType>? _content;

  /// The content of the request body.
  @override
  Map<String, MediaType>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableMapView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Reference to a response defined in [Components.requestBodies]
  @override
  @JsonKey(name: '\$ref')
  @_RequestRefConverter()
  final String? ref;

  @override
  String toString() {
    return 'RequestBody(description: $description, required: $required, content: $content, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RequestBody &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.required, required) ||
                other.required == required) &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description, required,
      const DeepCollectionEquality().hash(_content), ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RequestBodyCopyWith<_$_RequestBody> get copyWith =>
      __$$_RequestBodyCopyWithImpl<_$_RequestBody>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RequestBodyToJson(
      this,
    );
  }
}

abstract class _RequestBody extends RequestBody {
  const factory _RequestBody(
          {final String? description,
          final bool? required,
          final Map<String, MediaType>? content,
          @JsonKey(name: '\$ref') @_RequestRefConverter() final String? ref}) =
      _$_RequestBody;
  const _RequestBody._() : super._();

  factory _RequestBody.fromJson(Map<String, dynamic> json) =
      _$_RequestBody.fromJson;

  @override

  /// A brief description of the request body.
  String? get description;
  @override

  /// Determines if the request body is required in the request.
  bool? get required;
  @override

  /// The content of the request body.
  Map<String, MediaType>? get content;
  @override

  /// Reference to a response defined in [Components.requestBodies]
  @JsonKey(name: '\$ref')
  @_RequestRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_RequestBodyCopyWith<_$_RequestBody> get copyWith =>
      throw _privateConstructorUsedError;
}

Response _$ResponseFromJson(Map<String, dynamic> json) {
  return _Response.fromJson(json);
}

/// @nodoc
mixin _$Response {
  /// A description of the response
  String get description => throw _privateConstructorUsedError;

  /// Maps a header name to its definition. RFC7230 states header names are case insensitive.
  Map<String, Header>? get headers => throw _privateConstructorUsedError;

  /// A map containing descriptions of potential response payloads.
  Map<String, MediaType>? get content => throw _privateConstructorUsedError;

  /// A map containing descriptions of potential response payloads.
  Map<String, Link>? get links => throw _privateConstructorUsedError;

  /// Reference to a response defined in [Components.responses]
  @JsonKey(name: '\$ref')
  @_ResponseRefConverter()
  String? get ref => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ResponseCopyWith<Response> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseCopyWith<$Res> {
  factory $ResponseCopyWith(Response value, $Res Function(Response) then) =
      _$ResponseCopyWithImpl<$Res, Response>;
  @useResult
  $Res call(
      {String description,
      Map<String, Header>? headers,
      Map<String, MediaType>? content,
      Map<String, Link>? links,
      @JsonKey(name: '\$ref') @_ResponseRefConverter() String? ref});
}

/// @nodoc
class _$ResponseCopyWithImpl<$Res, $Val extends Response>
    implements $ResponseCopyWith<$Res> {
  _$ResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? headers = freezed,
    Object? content = freezed,
    Object? links = freezed,
    Object? ref = freezed,
  }) {
    return _then(_value.copyWith(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, Header>?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as Map<String, MediaType>?,
      links: freezed == links
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as Map<String, Link>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ResponseCopyWith<$Res> implements $ResponseCopyWith<$Res> {
  factory _$$_ResponseCopyWith(
          _$_Response value, $Res Function(_$_Response) then) =
      __$$_ResponseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String description,
      Map<String, Header>? headers,
      Map<String, MediaType>? content,
      Map<String, Link>? links,
      @JsonKey(name: '\$ref') @_ResponseRefConverter() String? ref});
}

/// @nodoc
class __$$_ResponseCopyWithImpl<$Res>
    extends _$ResponseCopyWithImpl<$Res, _$_Response>
    implements _$$_ResponseCopyWith<$Res> {
  __$$_ResponseCopyWithImpl(
      _$_Response _value, $Res Function(_$_Response) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = null,
    Object? headers = freezed,
    Object? content = freezed,
    Object? links = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_Response(
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      headers: freezed == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, Header>?,
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as Map<String, MediaType>?,
      links: freezed == links
          ? _value._links
          : links // ignore: cast_nullable_to_non_nullable
              as Map<String, Link>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Response extends _Response {
  const _$_Response(
      {this.description = '',
      final Map<String, Header>? headers,
      final Map<String, MediaType>? content,
      final Map<String, Link>? links,
      @JsonKey(name: '\$ref') @_ResponseRefConverter() this.ref})
      : _headers = headers,
        _content = content,
        _links = links,
        super._();

  factory _$_Response.fromJson(Map<String, dynamic> json) =>
      _$$_ResponseFromJson(json);

  /// A description of the response
  @override
  @JsonKey()
  final String description;

  /// Maps a header name to its definition. RFC7230 states header names are case insensitive.
  final Map<String, Header>? _headers;

  /// Maps a header name to its definition. RFC7230 states header names are case insensitive.
  @override
  Map<String, Header>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A map containing descriptions of potential response payloads.
  final Map<String, MediaType>? _content;

  /// A map containing descriptions of potential response payloads.
  @override
  Map<String, MediaType>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableMapView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// A map containing descriptions of potential response payloads.
  final Map<String, Link>? _links;

  /// A map containing descriptions of potential response payloads.
  @override
  Map<String, Link>? get links {
    final value = _links;
    if (value == null) return null;
    if (_links is EqualUnmodifiableMapView) return _links;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Reference to a response defined in [Components.responses]
  @override
  @JsonKey(name: '\$ref')
  @_ResponseRefConverter()
  final String? ref;

  @override
  String toString() {
    return 'Response(description: $description, headers: $headers, content: $content, links: $links, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Response &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            const DeepCollectionEquality().equals(other._links, _links) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      description,
      const DeepCollectionEquality().hash(_headers),
      const DeepCollectionEquality().hash(_content),
      const DeepCollectionEquality().hash(_links),
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ResponseCopyWith<_$_Response> get copyWith =>
      __$$_ResponseCopyWithImpl<_$_Response>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ResponseToJson(
      this,
    );
  }
}

abstract class _Response extends Response {
  const factory _Response(
          {final String description,
          final Map<String, Header>? headers,
          final Map<String, MediaType>? content,
          final Map<String, Link>? links,
          @JsonKey(name: '\$ref') @_ResponseRefConverter() final String? ref}) =
      _$_Response;
  const _Response._() : super._();

  factory _Response.fromJson(Map<String, dynamic> json) = _$_Response.fromJson;

  @override

  /// A description of the response
  String get description;
  @override

  /// Maps a header name to its definition. RFC7230 states header names are case insensitive.
  Map<String, Header>? get headers;
  @override

  /// A map containing descriptions of potential response payloads.
  Map<String, MediaType>? get content;
  @override

  /// A map containing descriptions of potential response payloads.
  Map<String, Link>? get links;
  @override

  /// Reference to a response defined in [Components.responses]
  @JsonKey(name: '\$ref')
  @_ResponseRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_ResponseCopyWith<_$_Response> get copyWith =>
      throw _privateConstructorUsedError;
}

Schema _$SchemaFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'boolean':
      return _SchemaBoolean.fromJson(json);
    case 'string':
      return _SchemaString.fromJson(json);
    case 'integer':
      return _SchemaInteger.fromJson(json);
    case 'number':
      return _SchemaNumber.fromJson(json);
    case 'enumeration':
      return _SchemaEnum.fromJson(json);
    case 'array':
      return _SchemaArray.fromJson(json);
    case 'map':
      return _SchemaMap.fromJson(json);

    default:
      return _SchemaObject.fromJson(json);
  }
}

/// @nodoc
mixin _$Schema {
  /// A summary title of the schema
  String? get title => throw _privateConstructorUsedError;

  /// A short description of the schema
  String? get description => throw _privateConstructorUsedError;

  /// Reference to a schema definition
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SchemaCopyWith<Schema> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SchemaCopyWith<$Res> {
  factory $SchemaCopyWith(Schema value, $Res Function(Schema) then) =
      _$SchemaCopyWithImpl<$Res, Schema>;
  @useResult
  $Res call(
      {String? title,
      String? description,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});
}

/// @nodoc
class _$SchemaCopyWithImpl<$Res, $Val extends Schema>
    implements $SchemaCopyWith<$Res> {
  _$SchemaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? description = freezed,
    Object? ref = freezed,
  }) {
    return _then(_value.copyWith(
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SchemaObjectCopyWith<$Res> implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaObjectCopyWith(
          _$_SchemaObject value, $Res Function(_$_SchemaObject) then) =
      __$$_SchemaObjectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? title,
      String? description,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
      @_SchemaListConverter() List<Schema>? allOf,
      List<String>? required,
      Discriminator? discriminator,
      ExternalDocs? externalDocs,
      Map<String, Schema>? properties,
      Xml? xml});

  $DiscriminatorCopyWith<$Res>? get discriminator;
  $ExternalDocsCopyWith<$Res>? get externalDocs;
  $XmlCopyWith<$Res>? get xml;
}

/// @nodoc
class __$$_SchemaObjectCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaObject>
    implements _$$_SchemaObjectCopyWith<$Res> {
  __$$_SchemaObjectCopyWithImpl(
      _$_SchemaObject _value, $Res Function(_$_SchemaObject) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? description = freezed,
    Object? ref = freezed,
    Object? allOf = freezed,
    Object? required = freezed,
    Object? discriminator = freezed,
    Object? externalDocs = freezed,
    Object? properties = freezed,
    Object? xml = freezed,
  }) {
    return _then(_$_SchemaObject(
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
      allOf: freezed == allOf
          ? _value._allOf
          : allOf // ignore: cast_nullable_to_non_nullable
              as List<Schema>?,
      required: freezed == required
          ? _value._required
          : required // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      discriminator: freezed == discriminator
          ? _value.discriminator
          : discriminator // ignore: cast_nullable_to_non_nullable
              as Discriminator?,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
      properties: freezed == properties
          ? _value._properties
          : properties // ignore: cast_nullable_to_non_nullable
              as Map<String, Schema>?,
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DiscriminatorCopyWith<$Res>? get discriminator {
    if (_value.discriminator == null) {
      return null;
    }

    return $DiscriminatorCopyWith<$Res>(_value.discriminator!, (value) {
      return _then(_value.copyWith(discriminator: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalDocsCopyWith<$Res>? get externalDocs {
    if (_value.externalDocs == null) {
      return null;
    }

    return $ExternalDocsCopyWith<$Res>(_value.externalDocs!, (value) {
      return _then(_value.copyWith(externalDocs: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaObject extends _SchemaObject {
  const _$_SchemaObject(
      {this.title,
      this.description,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      @_SchemaListConverter() final List<Schema>? allOf,
      final List<String>? required,
      this.discriminator,
      this.externalDocs,
      final Map<String, Schema>? properties,
      this.xml,
      final String? $type})
      : _allOf = allOf,
        _required = required,
        _properties = properties,
        $type = $type ?? 'object',
        super._();

  factory _$_SchemaObject.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaObjectFromJson(json);

  /// A summary title of the schema
  @override
  final String? title;

  /// A short description of the schema
  @override
  final String? description;

  /// Reference to a schema definition
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  /// The allOf definition
  final List<Schema>? _allOf;

  /// The allOf definition
  @override
  @_SchemaListConverter()
  List<Schema>? get allOf {
    final value = _allOf;
    if (value == null) return null;
    if (_allOf is EqualUnmodifiableListView) return _allOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The required properties of the schema
  final List<String>? _required;

  /// The required properties of the schema
  @override
  List<String>? get required {
    final value = _required;
    if (value == null) return null;
    if (_required is EqualUnmodifiableListView) return _required;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Adds support for polymorphism.
  /// The discriminator is an object name that is used to differentiate between
  /// other schemas which may satisfy the payload description
  @override
  final Discriminator? discriminator;

  /// Additional external documentation for this schema.
  @override
  final ExternalDocs? externalDocs;

  /// The properties of the schema
  final Map<String, Schema>? _properties;

  /// The properties of the schema
  @override
  Map<String, Schema>? get properties {
    final value = _properties;
    if (value == null) return null;
    if (_properties is EqualUnmodifiableMapView) return _properties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Any extra properties to add to this schema
// Schema? additionalProperties,
  /// Adds additional metadata to describe the XML representation of this property.
  @override
  final Xml? xml;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.object(title: $title, description: $description, ref: $ref, allOf: $allOf, required: $required, discriminator: $discriminator, externalDocs: $externalDocs, properties: $properties, xml: $xml)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaObject &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.ref, ref) || other.ref == ref) &&
            const DeepCollectionEquality().equals(other._allOf, _allOf) &&
            const DeepCollectionEquality().equals(other._required, _required) &&
            (identical(other.discriminator, discriminator) ||
                other.discriminator == discriminator) &&
            (identical(other.externalDocs, externalDocs) ||
                other.externalDocs == externalDocs) &&
            const DeepCollectionEquality()
                .equals(other._properties, _properties) &&
            (identical(other.xml, xml) || other.xml == xml));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      description,
      ref,
      const DeepCollectionEquality().hash(_allOf),
      const DeepCollectionEquality().hash(_required),
      discriminator,
      externalDocs,
      const DeepCollectionEquality().hash(_properties),
      xml);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaObjectCopyWith<_$_SchemaObject> get copyWith =>
      __$$_SchemaObjectCopyWithImpl<_$_SchemaObject>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return object(title, description, ref, allOf, required, discriminator,
        externalDocs, properties, xml);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return object?.call(title, description, ref, allOf, required, discriminator,
        externalDocs, properties, xml);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(title, description, ref, allOf, required, discriminator,
          externalDocs, properties, xml);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return object(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return object?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaObjectToJson(
      this,
    );
  }
}

abstract class _SchemaObject extends Schema {
  const factory _SchemaObject(
      {final String? title,
      final String? description,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref,
      @_SchemaListConverter() final List<Schema>? allOf,
      final List<String>? required,
      final Discriminator? discriminator,
      final ExternalDocs? externalDocs,
      final Map<String, Schema>? properties,
      final Xml? xml}) = _$_SchemaObject;
  const _SchemaObject._() : super._();

  factory _SchemaObject.fromJson(Map<String, dynamic> json) =
      _$_SchemaObject.fromJson;

  @override

  /// A summary title of the schema
  String? get title;
  @override

  /// A short description of the schema
  String? get description;
  @override

  /// Reference to a schema definition
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;

  /// The allOf definition
  @_SchemaListConverter()
  List<Schema>? get allOf;

  /// The required properties of the schema
  List<String>? get required;

  /// Adds support for polymorphism.
  /// The discriminator is an object name that is used to differentiate between
  /// other schemas which may satisfy the payload description
  Discriminator? get discriminator;

  /// Additional external documentation for this schema.
  ExternalDocs? get externalDocs;

  /// The properties of the schema
  Map<String, Schema>? get properties;

  /// Any extra properties to add to this schema
// Schema? additionalProperties,
  /// Adds additional metadata to describe the XML representation of this property.
  Xml? get xml;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaObjectCopyWith<_$_SchemaObject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaBooleanCopyWith<$Res>
    implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaBooleanCopyWith(
          _$_SchemaBoolean value, $Res Function(_$_SchemaBoolean) then) =
      __$$_SchemaBooleanCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Xml? xml,
      String? title,
      String? description,
      @JsonKey(name: 'default') bool? defaultValue,
      bool? example,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});

  $XmlCopyWith<$Res>? get xml;
}

/// @nodoc
class __$$_SchemaBooleanCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaBoolean>
    implements _$$_SchemaBooleanCopyWith<$Res> {
  __$$_SchemaBooleanCopyWithImpl(
      _$_SchemaBoolean _value, $Res Function(_$_SchemaBoolean) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xml = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? defaultValue = freezed,
    Object? example = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaBoolean(
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as bool?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as bool?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaBoolean extends _SchemaBoolean {
  const _$_SchemaBoolean(
      {this.xml,
      this.title,
      this.description,
      @JsonKey(name: 'default') this.defaultValue,
      this.example,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : $type = $type ?? 'boolean',
        super._();

  factory _$_SchemaBoolean.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaBooleanFromJson(json);

  @override
  final Xml? xml;
  @override
  final String? title;
  @override
  final String? description;
  @override
  @JsonKey(name: 'default')
  final bool? defaultValue;
  @override
  final bool? example;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.boolean(xml: $xml, title: $title, description: $description, defaultValue: $defaultValue, example: $example, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaBoolean &&
            (identical(other.xml, xml) || other.xml == xml) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, xml, title, description, defaultValue, example, ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaBooleanCopyWith<_$_SchemaBoolean> get copyWith =>
      __$$_SchemaBooleanCopyWithImpl<_$_SchemaBoolean>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return boolean(xml, title, description, defaultValue, example, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return boolean?.call(xml, title, description, defaultValue, example, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(xml, title, description, defaultValue, example, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaBooleanToJson(
      this,
    );
  }
}

abstract class _SchemaBoolean extends Schema {
  const factory _SchemaBoolean(
          {final Xml? xml,
          final String? title,
          final String? description,
          @JsonKey(name: 'default') final bool? defaultValue,
          final bool? example,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaBoolean;
  const _SchemaBoolean._() : super._();

  factory _SchemaBoolean.fromJson(Map<String, dynamic> json) =
      _$_SchemaBoolean.fromJson;

  Xml? get xml;
  @override
  String? get title;
  @override
  String? get description;
  @JsonKey(name: 'default')
  bool? get defaultValue;
  bool? get example;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaBooleanCopyWith<_$_SchemaBoolean> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaStringCopyWith<$Res> implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaStringCopyWith(
          _$_SchemaString value, $Res Function(_$_SchemaString) then) =
      __$$_SchemaStringCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Xml? xml,
      String? title,
      String? description,
      @JsonKey(name: 'default') String? defaultValue,
      StringFormat? format,
      String? example,
      int? minLength,
      int? maxLength,
      bool? exclusiveMinimum,
      bool? exclusiveMaximum,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});

  $XmlCopyWith<$Res>? get xml;
}

/// @nodoc
class __$$_SchemaStringCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaString>
    implements _$$_SchemaStringCopyWith<$Res> {
  __$$_SchemaStringCopyWithImpl(
      _$_SchemaString _value, $Res Function(_$_SchemaString) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xml = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? defaultValue = freezed,
    Object? format = freezed,
    Object? example = freezed,
    Object? minLength = freezed,
    Object? maxLength = freezed,
    Object? exclusiveMinimum = freezed,
    Object? exclusiveMaximum = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaString(
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as StringFormat?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      minLength: freezed == minLength
          ? _value.minLength
          : minLength // ignore: cast_nullable_to_non_nullable
              as int?,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      exclusiveMinimum: freezed == exclusiveMinimum
          ? _value.exclusiveMinimum
          : exclusiveMinimum // ignore: cast_nullable_to_non_nullable
              as bool?,
      exclusiveMaximum: freezed == exclusiveMaximum
          ? _value.exclusiveMaximum
          : exclusiveMaximum // ignore: cast_nullable_to_non_nullable
              as bool?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaString extends _SchemaString {
  const _$_SchemaString(
      {this.xml,
      this.title,
      this.description,
      @JsonKey(name: 'default') this.defaultValue,
      this.format,
      this.example,
      this.minLength,
      this.maxLength,
      this.exclusiveMinimum,
      this.exclusiveMaximum,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : $type = $type ?? 'string',
        super._();

  factory _$_SchemaString.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaStringFromJson(json);

  @override
  final Xml? xml;
  @override
  final String? title;
  @override
  final String? description;
  @override
  @JsonKey(name: 'default')
  final String? defaultValue;
  @override
  final StringFormat? format;
  @override
  final String? example;
  @override
  final int? minLength;
  @override
  final int? maxLength;
  @override
  final bool? exclusiveMinimum;
  @override
  final bool? exclusiveMaximum;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.string(xml: $xml, title: $title, description: $description, defaultValue: $defaultValue, format: $format, example: $example, minLength: $minLength, maxLength: $maxLength, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaString &&
            (identical(other.xml, xml) || other.xml == xml) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.minLength, minLength) ||
                other.minLength == minLength) &&
            (identical(other.maxLength, maxLength) ||
                other.maxLength == maxLength) &&
            (identical(other.exclusiveMinimum, exclusiveMinimum) ||
                other.exclusiveMinimum == exclusiveMinimum) &&
            (identical(other.exclusiveMaximum, exclusiveMaximum) ||
                other.exclusiveMaximum == exclusiveMaximum) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      xml,
      title,
      description,
      defaultValue,
      format,
      example,
      minLength,
      maxLength,
      exclusiveMinimum,
      exclusiveMaximum,
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaStringCopyWith<_$_SchemaString> get copyWith =>
      __$$_SchemaStringCopyWithImpl<_$_SchemaString>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return string(xml, title, description, defaultValue, format, example,
        minLength, maxLength, exclusiveMinimum, exclusiveMaximum, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return string?.call(xml, title, description, defaultValue, format, example,
        minLength, maxLength, exclusiveMinimum, exclusiveMaximum, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(xml, title, description, defaultValue, format, example,
          minLength, maxLength, exclusiveMinimum, exclusiveMaximum, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaStringToJson(
      this,
    );
  }
}

abstract class _SchemaString extends Schema {
  const factory _SchemaString(
          {final Xml? xml,
          final String? title,
          final String? description,
          @JsonKey(name: 'default') final String? defaultValue,
          final StringFormat? format,
          final String? example,
          final int? minLength,
          final int? maxLength,
          final bool? exclusiveMinimum,
          final bool? exclusiveMaximum,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaString;
  const _SchemaString._() : super._();

  factory _SchemaString.fromJson(Map<String, dynamic> json) =
      _$_SchemaString.fromJson;

  Xml? get xml;
  @override
  String? get title;
  @override
  String? get description;
  @JsonKey(name: 'default')
  String? get defaultValue;
  StringFormat? get format;
  String? get example;
  int? get minLength;
  int? get maxLength;
  bool? get exclusiveMinimum;
  bool? get exclusiveMaximum;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaStringCopyWith<_$_SchemaString> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaIntegerCopyWith<$Res>
    implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaIntegerCopyWith(
          _$_SchemaInteger value, $Res Function(_$_SchemaInteger) then) =
      __$$_SchemaIntegerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Xml? xml,
      String? title,
      String? description,
      @JsonKey(name: 'default') int? defaultValue,
      IntegerFormat? format,
      int? example,
      int? minimum,
      int? maximum,
      bool? exclusiveMinimum,
      bool? exclusiveMaximum,
      int? multipleOf,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});

  $XmlCopyWith<$Res>? get xml;
}

/// @nodoc
class __$$_SchemaIntegerCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaInteger>
    implements _$$_SchemaIntegerCopyWith<$Res> {
  __$$_SchemaIntegerCopyWithImpl(
      _$_SchemaInteger _value, $Res Function(_$_SchemaInteger) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xml = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? defaultValue = freezed,
    Object? format = freezed,
    Object? example = freezed,
    Object? minimum = freezed,
    Object? maximum = freezed,
    Object? exclusiveMinimum = freezed,
    Object? exclusiveMaximum = freezed,
    Object? multipleOf = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaInteger(
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as int?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as IntegerFormat?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as int?,
      minimum: freezed == minimum
          ? _value.minimum
          : minimum // ignore: cast_nullable_to_non_nullable
              as int?,
      maximum: freezed == maximum
          ? _value.maximum
          : maximum // ignore: cast_nullable_to_non_nullable
              as int?,
      exclusiveMinimum: freezed == exclusiveMinimum
          ? _value.exclusiveMinimum
          : exclusiveMinimum // ignore: cast_nullable_to_non_nullable
              as bool?,
      exclusiveMaximum: freezed == exclusiveMaximum
          ? _value.exclusiveMaximum
          : exclusiveMaximum // ignore: cast_nullable_to_non_nullable
              as bool?,
      multipleOf: freezed == multipleOf
          ? _value.multipleOf
          : multipleOf // ignore: cast_nullable_to_non_nullable
              as int?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaInteger extends _SchemaInteger {
  const _$_SchemaInteger(
      {this.xml,
      this.title,
      this.description,
      @JsonKey(name: 'default') this.defaultValue,
      this.format,
      this.example,
      this.minimum,
      this.maximum,
      this.exclusiveMinimum,
      this.exclusiveMaximum,
      this.multipleOf,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : $type = $type ?? 'integer',
        super._();

  factory _$_SchemaInteger.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaIntegerFromJson(json);

  @override
  final Xml? xml;
  @override
  final String? title;
  @override
  final String? description;
  @override
  @JsonKey(name: 'default')
  final int? defaultValue;
  @override
  final IntegerFormat? format;
  @override
  final int? example;
  @override
  final int? minimum;
  @override
  final int? maximum;
  @override
  final bool? exclusiveMinimum;
  @override
  final bool? exclusiveMaximum;
  @override
  final int? multipleOf;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.integer(xml: $xml, title: $title, description: $description, defaultValue: $defaultValue, format: $format, example: $example, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaInteger &&
            (identical(other.xml, xml) || other.xml == xml) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.minimum, minimum) || other.minimum == minimum) &&
            (identical(other.maximum, maximum) || other.maximum == maximum) &&
            (identical(other.exclusiveMinimum, exclusiveMinimum) ||
                other.exclusiveMinimum == exclusiveMinimum) &&
            (identical(other.exclusiveMaximum, exclusiveMaximum) ||
                other.exclusiveMaximum == exclusiveMaximum) &&
            (identical(other.multipleOf, multipleOf) ||
                other.multipleOf == multipleOf) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      xml,
      title,
      description,
      defaultValue,
      format,
      example,
      minimum,
      maximum,
      exclusiveMinimum,
      exclusiveMaximum,
      multipleOf,
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaIntegerCopyWith<_$_SchemaInteger> get copyWith =>
      __$$_SchemaIntegerCopyWithImpl<_$_SchemaInteger>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return integer(xml, title, description, defaultValue, format, example,
        minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return integer?.call(xml, title, description, defaultValue, format, example,
        minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(
          xml,
          title,
          description,
          defaultValue,
          format,
          example,
          minimum,
          maximum,
          exclusiveMinimum,
          exclusiveMaximum,
          multipleOf,
          ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return integer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return integer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaIntegerToJson(
      this,
    );
  }
}

abstract class _SchemaInteger extends Schema {
  const factory _SchemaInteger(
          {final Xml? xml,
          final String? title,
          final String? description,
          @JsonKey(name: 'default') final int? defaultValue,
          final IntegerFormat? format,
          final int? example,
          final int? minimum,
          final int? maximum,
          final bool? exclusiveMinimum,
          final bool? exclusiveMaximum,
          final int? multipleOf,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaInteger;
  const _SchemaInteger._() : super._();

  factory _SchemaInteger.fromJson(Map<String, dynamic> json) =
      _$_SchemaInteger.fromJson;

  Xml? get xml;
  @override
  String? get title;
  @override
  String? get description;
  @JsonKey(name: 'default')
  int? get defaultValue;
  IntegerFormat? get format;
  int? get example;
  int? get minimum;
  int? get maximum;
  bool? get exclusiveMinimum;
  bool? get exclusiveMaximum;
  int? get multipleOf;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaIntegerCopyWith<_$_SchemaInteger> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaNumberCopyWith<$Res> implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaNumberCopyWith(
          _$_SchemaNumber value, $Res Function(_$_SchemaNumber) then) =
      __$$_SchemaNumberCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Xml? xml,
      String? title,
      String? description,
      @JsonKey(name: 'default') double? defaultValue,
      NumberFormat? format,
      double? example,
      double? minimum,
      double? maximum,
      bool? exclusiveMinimum,
      bool? exclusiveMaximum,
      double? multipleOf,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});

  $XmlCopyWith<$Res>? get xml;
}

/// @nodoc
class __$$_SchemaNumberCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaNumber>
    implements _$$_SchemaNumberCopyWith<$Res> {
  __$$_SchemaNumberCopyWithImpl(
      _$_SchemaNumber _value, $Res Function(_$_SchemaNumber) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xml = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? defaultValue = freezed,
    Object? format = freezed,
    Object? example = freezed,
    Object? minimum = freezed,
    Object? maximum = freezed,
    Object? exclusiveMinimum = freezed,
    Object? exclusiveMaximum = freezed,
    Object? multipleOf = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaNumber(
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as double?,
      format: freezed == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as NumberFormat?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as double?,
      minimum: freezed == minimum
          ? _value.minimum
          : minimum // ignore: cast_nullable_to_non_nullable
              as double?,
      maximum: freezed == maximum
          ? _value.maximum
          : maximum // ignore: cast_nullable_to_non_nullable
              as double?,
      exclusiveMinimum: freezed == exclusiveMinimum
          ? _value.exclusiveMinimum
          : exclusiveMinimum // ignore: cast_nullable_to_non_nullable
              as bool?,
      exclusiveMaximum: freezed == exclusiveMaximum
          ? _value.exclusiveMaximum
          : exclusiveMaximum // ignore: cast_nullable_to_non_nullable
              as bool?,
      multipleOf: freezed == multipleOf
          ? _value.multipleOf
          : multipleOf // ignore: cast_nullable_to_non_nullable
              as double?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaNumber extends _SchemaNumber {
  const _$_SchemaNumber(
      {this.xml,
      this.title,
      this.description,
      @JsonKey(name: 'default') this.defaultValue,
      this.format,
      this.example,
      this.minimum,
      this.maximum,
      this.exclusiveMinimum,
      this.exclusiveMaximum,
      this.multipleOf,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : $type = $type ?? 'number',
        super._();

  factory _$_SchemaNumber.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaNumberFromJson(json);

  @override
  final Xml? xml;
  @override
  final String? title;
  @override
  final String? description;
  @override
  @JsonKey(name: 'default')
  final double? defaultValue;
  @override
  final NumberFormat? format;
  @override
  final double? example;
  @override
  final double? minimum;
  @override
  final double? maximum;
  @override
  final bool? exclusiveMinimum;
  @override
  final bool? exclusiveMaximum;
  @override
  final double? multipleOf;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.number(xml: $xml, title: $title, description: $description, defaultValue: $defaultValue, format: $format, example: $example, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaNumber &&
            (identical(other.xml, xml) || other.xml == xml) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.minimum, minimum) || other.minimum == minimum) &&
            (identical(other.maximum, maximum) || other.maximum == maximum) &&
            (identical(other.exclusiveMinimum, exclusiveMinimum) ||
                other.exclusiveMinimum == exclusiveMinimum) &&
            (identical(other.exclusiveMaximum, exclusiveMaximum) ||
                other.exclusiveMaximum == exclusiveMaximum) &&
            (identical(other.multipleOf, multipleOf) ||
                other.multipleOf == multipleOf) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      xml,
      title,
      description,
      defaultValue,
      format,
      example,
      minimum,
      maximum,
      exclusiveMinimum,
      exclusiveMaximum,
      multipleOf,
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaNumberCopyWith<_$_SchemaNumber> get copyWith =>
      __$$_SchemaNumberCopyWithImpl<_$_SchemaNumber>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return number(xml, title, description, defaultValue, format, example,
        minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return number?.call(xml, title, description, defaultValue, format, example,
        minimum, maximum, exclusiveMinimum, exclusiveMaximum, multipleOf, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(
          xml,
          title,
          description,
          defaultValue,
          format,
          example,
          minimum,
          maximum,
          exclusiveMinimum,
          exclusiveMaximum,
          multipleOf,
          ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return number(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return number?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (number != null) {
      return number(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaNumberToJson(
      this,
    );
  }
}

abstract class _SchemaNumber extends Schema {
  const factory _SchemaNumber(
          {final Xml? xml,
          final String? title,
          final String? description,
          @JsonKey(name: 'default') final double? defaultValue,
          final NumberFormat? format,
          final double? example,
          final double? minimum,
          final double? maximum,
          final bool? exclusiveMinimum,
          final bool? exclusiveMaximum,
          final double? multipleOf,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaNumber;
  const _SchemaNumber._() : super._();

  factory _SchemaNumber.fromJson(Map<String, dynamic> json) =
      _$_SchemaNumber.fromJson;

  Xml? get xml;
  @override
  String? get title;
  @override
  String? get description;
  @JsonKey(name: 'default')
  double? get defaultValue;
  NumberFormat? get format;
  double? get example;
  double? get minimum;
  double? get maximum;
  bool? get exclusiveMinimum;
  bool? get exclusiveMaximum;
  double? get multipleOf;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaNumberCopyWith<_$_SchemaNumber> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaEnumCopyWith<$Res> implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaEnumCopyWith(
          _$_SchemaEnum value, $Res Function(_$_SchemaEnum) then) =
      __$$_SchemaEnumCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? title,
      String? description,
      String? example,
      @JsonKey(name: 'default') String? defaultValue,
      @JsonKey(includeToJson: false, includeFromJson: false)
      String? unknownValue,
      @JsonKey(name: 'enum') List<String>? values,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});
}

/// @nodoc
class __$$_SchemaEnumCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaEnum>
    implements _$$_SchemaEnumCopyWith<$Res> {
  __$$_SchemaEnumCopyWithImpl(
      _$_SchemaEnum _value, $Res Function(_$_SchemaEnum) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = freezed,
    Object? description = freezed,
    Object? example = freezed,
    Object? defaultValue = freezed,
    Object? unknownValue = freezed,
    Object? values = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaEnum(
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      example: freezed == example
          ? _value.example
          : example // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      unknownValue: freezed == unknownValue
          ? _value.unknownValue
          : unknownValue // ignore: cast_nullable_to_non_nullable
              as String?,
      values: freezed == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaEnum extends _SchemaEnum {
  const _$_SchemaEnum(
      {this.title,
      this.description,
      this.example,
      @JsonKey(name: 'default') this.defaultValue,
      @JsonKey(includeToJson: false, includeFromJson: false) this.unknownValue,
      @JsonKey(name: 'enum') final List<String>? values,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : assert(
            values == null || ref == null, 'Cannot define both values and ref'),
        _values = values,
        $type = $type ?? 'enumeration',
        super._();

  factory _$_SchemaEnum.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaEnumFromJson(json);

  @override
  final String? title;
  @override
  final String? description;
  @override
  final String? example;
  @override
  @JsonKey(name: 'default')
  final String? defaultValue;
  @override
  @JsonKey(includeToJson: false, includeFromJson: false)
  final String? unknownValue;
  final List<String>? _values;
  @override
  @JsonKey(name: 'enum')
  List<String>? get values {
    final value = _values;
    if (value == null) return null;
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.enumeration(title: $title, description: $description, example: $example, defaultValue: $defaultValue, unknownValue: $unknownValue, values: $values, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaEnum &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.example, example) || other.example == example) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.unknownValue, unknownValue) ||
                other.unknownValue == unknownValue) &&
            const DeepCollectionEquality().equals(other._values, _values) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      title,
      description,
      example,
      defaultValue,
      unknownValue,
      const DeepCollectionEquality().hash(_values),
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaEnumCopyWith<_$_SchemaEnum> get copyWith =>
      __$$_SchemaEnumCopyWithImpl<_$_SchemaEnum>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return enumeration(
        title, description, example, defaultValue, unknownValue, values, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return enumeration?.call(
        title, description, example, defaultValue, unknownValue, values, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(
          title, description, example, defaultValue, unknownValue, values, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return enumeration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return enumeration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (enumeration != null) {
      return enumeration(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaEnumToJson(
      this,
    );
  }
}

abstract class _SchemaEnum extends Schema {
  const factory _SchemaEnum(
          {final String? title,
          final String? description,
          final String? example,
          @JsonKey(name: 'default') final String? defaultValue,
          @JsonKey(includeToJson: false, includeFromJson: false)
          final String? unknownValue,
          @JsonKey(name: 'enum') final List<String>? values,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaEnum;
  const _SchemaEnum._() : super._();

  factory _SchemaEnum.fromJson(Map<String, dynamic> json) =
      _$_SchemaEnum.fromJson;

  @override
  String? get title;
  @override
  String? get description;
  String? get example;
  @JsonKey(name: 'default')
  String? get defaultValue;
  @JsonKey(includeToJson: false, includeFromJson: false)
  String? get unknownValue;
  @JsonKey(name: 'enum')
  List<String>? get values;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaEnumCopyWith<_$_SchemaEnum> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaArrayCopyWith<$Res> implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaArrayCopyWith(
          _$_SchemaArray value, $Res Function(_$_SchemaArray) then) =
      __$$_SchemaArrayCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Xml? xml,
      String? title,
      String? description,
      @JsonKey(name: 'default') List<dynamic>? defaultValue,
      List<dynamic>? example,
      int? minItems,
      int? maxItems,
      Schema items,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});

  $XmlCopyWith<$Res>? get xml;
  $SchemaCopyWith<$Res> get items;
}

/// @nodoc
class __$$_SchemaArrayCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaArray>
    implements _$$_SchemaArrayCopyWith<$Res> {
  __$$_SchemaArrayCopyWithImpl(
      _$_SchemaArray _value, $Res Function(_$_SchemaArray) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xml = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? defaultValue = freezed,
    Object? example = freezed,
    Object? minItems = freezed,
    Object? maxItems = freezed,
    Object? items = null,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaArray(
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value._defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      example: freezed == example
          ? _value._example
          : example // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      minItems: freezed == minItems
          ? _value.minItems
          : minItems // ignore: cast_nullable_to_non_nullable
              as int?,
      maxItems: freezed == maxItems
          ? _value.maxItems
          : maxItems // ignore: cast_nullable_to_non_nullable
              as int?,
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as Schema,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SchemaCopyWith<$Res> get items {
    return $SchemaCopyWith<$Res>(_value.items, (value) {
      return _then(_value.copyWith(items: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaArray extends _SchemaArray {
  const _$_SchemaArray(
      {this.xml,
      this.title,
      this.description,
      @JsonKey(name: 'default') final List<dynamic>? defaultValue,
      final List<dynamic>? example,
      this.minItems,
      this.maxItems,
      required this.items,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : _defaultValue = defaultValue,
        _example = example,
        $type = $type ?? 'array',
        super._();

  factory _$_SchemaArray.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaArrayFromJson(json);

  @override
  final Xml? xml;
  @override
  final String? title;
  @override
  final String? description;
  final List<dynamic>? _defaultValue;
  @override
  @JsonKey(name: 'default')
  List<dynamic>? get defaultValue {
    final value = _defaultValue;
    if (value == null) return null;
    if (_defaultValue is EqualUnmodifiableListView) return _defaultValue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<dynamic>? _example;
  @override
  List<dynamic>? get example {
    final value = _example;
    if (value == null) return null;
    if (_example is EqualUnmodifiableListView) return _example;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? minItems;
  @override
  final int? maxItems;
  @override
  final Schema items;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.array(xml: $xml, title: $title, description: $description, defaultValue: $defaultValue, example: $example, minItems: $minItems, maxItems: $maxItems, items: $items, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaArray &&
            (identical(other.xml, xml) || other.xml == xml) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._defaultValue, _defaultValue) &&
            const DeepCollectionEquality().equals(other._example, _example) &&
            (identical(other.minItems, minItems) ||
                other.minItems == minItems) &&
            (identical(other.maxItems, maxItems) ||
                other.maxItems == maxItems) &&
            (identical(other.items, items) || other.items == items) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      xml,
      title,
      description,
      const DeepCollectionEquality().hash(_defaultValue),
      const DeepCollectionEquality().hash(_example),
      minItems,
      maxItems,
      items,
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaArrayCopyWith<_$_SchemaArray> get copyWith =>
      __$$_SchemaArrayCopyWithImpl<_$_SchemaArray>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return array(xml, title, description, defaultValue, example, minItems,
        maxItems, items, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return array?.call(xml, title, description, defaultValue, example, minItems,
        maxItems, items, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(xml, title, description, defaultValue, example, minItems,
          maxItems, items, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaArrayToJson(
      this,
    );
  }
}

abstract class _SchemaArray extends Schema {
  const factory _SchemaArray(
          {final Xml? xml,
          final String? title,
          final String? description,
          @JsonKey(name: 'default') final List<dynamic>? defaultValue,
          final List<dynamic>? example,
          final int? minItems,
          final int? maxItems,
          required final Schema items,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaArray;
  const _SchemaArray._() : super._();

  factory _SchemaArray.fromJson(Map<String, dynamic> json) =
      _$_SchemaArray.fromJson;

  Xml? get xml;
  @override
  String? get title;
  @override
  String? get description;
  @JsonKey(name: 'default')
  List<dynamic>? get defaultValue;
  List<dynamic>? get example;
  int? get minItems;
  int? get maxItems;
  Schema get items;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaArrayCopyWith<_$_SchemaArray> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SchemaMapCopyWith<$Res> implements $SchemaCopyWith<$Res> {
  factory _$$_SchemaMapCopyWith(
          _$_SchemaMap value, $Res Function(_$_SchemaMap) then) =
      __$$_SchemaMapCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Xml? xml,
      String? title,
      String? description,
      @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
      Map<dynamic, dynamic>? example,
      @JsonKey(
          name: 'additionalProperties',
          toJson: _toMapProps,
          fromJson: _fromMapProps)
      Schema? valueSchema,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref});

  $XmlCopyWith<$Res>? get xml;
  $SchemaCopyWith<$Res>? get valueSchema;
}

/// @nodoc
class __$$_SchemaMapCopyWithImpl<$Res>
    extends _$SchemaCopyWithImpl<$Res, _$_SchemaMap>
    implements _$$_SchemaMapCopyWith<$Res> {
  __$$_SchemaMapCopyWithImpl(
      _$_SchemaMap _value, $Res Function(_$_SchemaMap) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? xml = freezed,
    Object? title = freezed,
    Object? description = freezed,
    Object? defaultValue = freezed,
    Object? example = freezed,
    Object? valueSchema = freezed,
    Object? ref = freezed,
  }) {
    return _then(_$_SchemaMap(
      xml: freezed == xml
          ? _value.xml
          : xml // ignore: cast_nullable_to_non_nullable
              as Xml?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      defaultValue: freezed == defaultValue
          ? _value._defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as Map<dynamic, dynamic>?,
      example: freezed == example
          ? _value._example
          : example // ignore: cast_nullable_to_non_nullable
              as Map<dynamic, dynamic>?,
      valueSchema: freezed == valueSchema
          ? _value.valueSchema
          : valueSchema // ignore: cast_nullable_to_non_nullable
              as Schema?,
      ref: freezed == ref
          ? _value.ref
          : ref // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $XmlCopyWith<$Res>? get xml {
    if (_value.xml == null) {
      return null;
    }

    return $XmlCopyWith<$Res>(_value.xml!, (value) {
      return _then(_value.copyWith(xml: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SchemaCopyWith<$Res>? get valueSchema {
    if (_value.valueSchema == null) {
      return null;
    }

    return $SchemaCopyWith<$Res>(_value.valueSchema!, (value) {
      return _then(_value.copyWith(valueSchema: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SchemaMap extends _SchemaMap {
  const _$_SchemaMap(
      {this.xml,
      this.title,
      this.description,
      @JsonKey(name: 'default') final Map<dynamic, dynamic>? defaultValue,
      final Map<dynamic, dynamic>? example,
      @JsonKey(
          name: 'additionalProperties',
          toJson: _toMapProps,
          fromJson: _fromMapProps)
      this.valueSchema,
      @JsonKey(name: '\$ref') @_SchemaRefConverter() this.ref,
      final String? $type})
      : _defaultValue = defaultValue,
        _example = example,
        $type = $type ?? 'map',
        super._();

  factory _$_SchemaMap.fromJson(Map<String, dynamic> json) =>
      _$$_SchemaMapFromJson(json);

  @override
  final Xml? xml;
  @override
  final String? title;
  @override
  final String? description;
  final Map<dynamic, dynamic>? _defaultValue;
  @override
  @JsonKey(name: 'default')
  Map<dynamic, dynamic>? get defaultValue {
    final value = _defaultValue;
    if (value == null) return null;
    if (_defaultValue is EqualUnmodifiableMapView) return _defaultValue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<dynamic, dynamic>? _example;
  @override
  Map<dynamic, dynamic>? get example {
    final value = _example;
    if (value == null) return null;
    if (_example is EqualUnmodifiableMapView) return _example;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @JsonKey(
      name: 'additionalProperties',
      toJson: _toMapProps,
      fromJson: _fromMapProps)
  final Schema? valueSchema;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  final String? ref;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'Schema.map(xml: $xml, title: $title, description: $description, defaultValue: $defaultValue, example: $example, valueSchema: $valueSchema, ref: $ref)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SchemaMap &&
            (identical(other.xml, xml) || other.xml == xml) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._defaultValue, _defaultValue) &&
            const DeepCollectionEquality().equals(other._example, _example) &&
            (identical(other.valueSchema, valueSchema) ||
                other.valueSchema == valueSchema) &&
            (identical(other.ref, ref) || other.ref == ref));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      xml,
      title,
      description,
      const DeepCollectionEquality().hash(_defaultValue),
      const DeepCollectionEquality().hash(_example),
      valueSchema,
      ref);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SchemaMapCopyWith<_$_SchemaMap> get copyWith =>
      __$$_SchemaMapCopyWithImpl<_$_SchemaMap>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)
        object,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        boolean,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        string,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        integer,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        number,
    required TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        enumeration,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        array,
    required TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)
        map,
  }) {
    return map(
        xml, title, description, defaultValue, example, valueSchema, ref);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult? Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult? Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
  }) {
    return map?.call(
        xml, title, description, defaultValue, example, valueSchema, ref);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            String? title,
            String? description,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref,
            @_SchemaListConverter() List<Schema>? allOf,
            List<String>? required,
            Discriminator? discriminator,
            ExternalDocs? externalDocs,
            Map<String, Schema>? properties,
            Xml? xml)?
        object,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') bool? defaultValue,
            bool? example,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        boolean,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') String? defaultValue,
            StringFormat? format,
            String? example,
            int? minLength,
            int? maxLength,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        string,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') int? defaultValue,
            IntegerFormat? format,
            int? example,
            int? minimum,
            int? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            int? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        integer,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') double? defaultValue,
            NumberFormat? format,
            double? example,
            double? minimum,
            double? maximum,
            bool? exclusiveMinimum,
            bool? exclusiveMaximum,
            double? multipleOf,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        number,
    TResult Function(
            String? title,
            String? description,
            String? example,
            @JsonKey(name: 'default') String? defaultValue,
            @JsonKey(includeToJson: false, includeFromJson: false)
            String? unknownValue,
            @JsonKey(name: 'enum') List<String>? values,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        enumeration,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') List<dynamic>? defaultValue,
            List<dynamic>? example,
            int? minItems,
            int? maxItems,
            Schema items,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        array,
    TResult Function(
            Xml? xml,
            String? title,
            String? description,
            @JsonKey(name: 'default') Map<dynamic, dynamic>? defaultValue,
            Map<dynamic, dynamic>? example,
            @JsonKey(
                name: 'additionalProperties',
                toJson: _toMapProps,
                fromJson: _fromMapProps)
            Schema? valueSchema,
            @JsonKey(name: '\$ref') @_SchemaRefConverter() String? ref)?
        map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(
          xml, title, description, defaultValue, example, valueSchema, ref);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SchemaObject value) object,
    required TResult Function(_SchemaBoolean value) boolean,
    required TResult Function(_SchemaString value) string,
    required TResult Function(_SchemaInteger value) integer,
    required TResult Function(_SchemaNumber value) number,
    required TResult Function(_SchemaEnum value) enumeration,
    required TResult Function(_SchemaArray value) array,
    required TResult Function(_SchemaMap value) map,
  }) {
    return map(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SchemaObject value)? object,
    TResult? Function(_SchemaBoolean value)? boolean,
    TResult? Function(_SchemaString value)? string,
    TResult? Function(_SchemaInteger value)? integer,
    TResult? Function(_SchemaNumber value)? number,
    TResult? Function(_SchemaEnum value)? enumeration,
    TResult? Function(_SchemaArray value)? array,
    TResult? Function(_SchemaMap value)? map,
  }) {
    return map?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SchemaObject value)? object,
    TResult Function(_SchemaBoolean value)? boolean,
    TResult Function(_SchemaString value)? string,
    TResult Function(_SchemaInteger value)? integer,
    TResult Function(_SchemaNumber value)? number,
    TResult Function(_SchemaEnum value)? enumeration,
    TResult Function(_SchemaArray value)? array,
    TResult Function(_SchemaMap value)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SchemaMapToJson(
      this,
    );
  }
}

abstract class _SchemaMap extends Schema {
  const factory _SchemaMap(
          {final Xml? xml,
          final String? title,
          final String? description,
          @JsonKey(name: 'default') final Map<dynamic, dynamic>? defaultValue,
          final Map<dynamic, dynamic>? example,
          @JsonKey(
              name: 'additionalProperties',
              toJson: _toMapProps,
              fromJson: _fromMapProps)
          final Schema? valueSchema,
          @JsonKey(name: '\$ref') @_SchemaRefConverter() final String? ref}) =
      _$_SchemaMap;
  const _SchemaMap._() : super._();

  factory _SchemaMap.fromJson(Map<String, dynamic> json) =
      _$_SchemaMap.fromJson;

  Xml? get xml;
  @override
  String? get title;
  @override
  String? get description;
  @JsonKey(name: 'default')
  Map<dynamic, dynamic>? get defaultValue;
  Map<dynamic, dynamic>? get example;
  @JsonKey(
      name: 'additionalProperties',
      toJson: _toMapProps,
      fromJson: _fromMapProps)
  Schema? get valueSchema;
  @override
  @JsonKey(name: '\$ref')
  @_SchemaRefConverter()
  String? get ref;
  @override
  @JsonKey(ignore: true)
  _$$_SchemaMapCopyWith<_$_SchemaMap> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Security {
  /// Each name must correspond to a security scheme which is declared
  /// in the [Components.securitySchemes] list
  String? get name => throw _privateConstructorUsedError;

  /// List of scopes required to access the API, if any.
  List<String> get scopes => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SecurityCopyWith<Security> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SecurityCopyWith<$Res> {
  factory $SecurityCopyWith(Security value, $Res Function(Security) then) =
      _$SecurityCopyWithImpl<$Res, Security>;
  @useResult
  $Res call({String? name, List<String> scopes});
}

/// @nodoc
class _$SecurityCopyWithImpl<$Res, $Val extends Security>
    implements $SecurityCopyWith<$Res> {
  _$SecurityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? scopes = null,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value.scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SecurityCopyWith<$Res> implements $SecurityCopyWith<$Res> {
  factory _$$_SecurityCopyWith(
          _$_Security value, $Res Function(_$_Security) then) =
      __$$_SecurityCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, List<String> scopes});
}

/// @nodoc
class __$$_SecurityCopyWithImpl<$Res>
    extends _$SecurityCopyWithImpl<$Res, _$_Security>
    implements _$$_SecurityCopyWith<$Res> {
  __$$_SecurityCopyWithImpl(
      _$_Security _value, $Res Function(_$_Security) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? scopes = null,
  }) {
    return _then(_$_Security(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      scopes: null == scopes
          ? _value._scopes
          : scopes // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$_Security extends _Security {
  const _$_Security({this.name, final List<String> scopes = const []})
      : _scopes = scopes,
        super._();

  /// Each name must correspond to a security scheme which is declared
  /// in the [Components.securitySchemes] list
  @override
  final String? name;

  /// List of scopes required to access the API, if any.
  final List<String> _scopes;

  /// List of scopes required to access the API, if any.
  @override
  @JsonKey()
  List<String> get scopes {
    if (_scopes is EqualUnmodifiableListView) return _scopes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_scopes);
  }

  @override
  String toString() {
    return 'Security(name: $name, scopes: $scopes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Security &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._scopes, _scopes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(_scopes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecurityCopyWith<_$_Security> get copyWith =>
      __$$_SecurityCopyWithImpl<_$_Security>(this, _$identity);
}

abstract class _Security extends Security {
  const factory _Security({final String? name, final List<String> scopes}) =
      _$_Security;
  const _Security._() : super._();

  @override

  /// Each name must correspond to a security scheme which is declared
  /// in the [Components.securitySchemes] list
  String? get name;
  @override

  /// List of scopes required to access the API, if any.
  List<String> get scopes;
  @override
  @JsonKey(ignore: true)
  _$$_SecurityCopyWith<_$_Security> get copyWith =>
      throw _privateConstructorUsedError;
}

SecurityScheme _$SecuritySchemeFromJson(Map<String, dynamic> json) {
  switch (json['type']) {
    case 'apiKey':
      return _SecuritySchemeApiKey.fromJson(json);
    case 'http':
      return _SecuritySchemeHttp.fromJson(json);
    case 'mutualTLS':
      return _SecuritySchemeMutualTLS.fromJson(json);
    case 'oauth2':
      return _SecuritySchemeOauth2.fromJson(json);
    case 'openIdConnect':
      return _SecuritySchemeOpenIdConnect.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'type', 'SecurityScheme',
          'Invalid union type "${json['type']}"!');
  }
}

/// @nodoc
mixin _$SecurityScheme {
  /// A description for security scheme.
  String? get description => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)
        apiKey,
    required TResult Function(
            String scheme, String bearerFormat, String? description)
        http,
    required TResult Function(String? description) mutualTLS,
    required TResult Function(String? description, OAuthFlows flows) oauth2,
    required TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)
        openIdConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult? Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult? Function(String? description)? mutualTLS,
    TResult? Function(String? description, OAuthFlows flows)? oauth2,
    TResult? Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult Function(String? description)? mutualTLS,
    TResult Function(String? description, OAuthFlows flows)? oauth2,
    TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SecuritySchemeApiKey value) apiKey,
    required TResult Function(_SecuritySchemeHttp value) http,
    required TResult Function(_SecuritySchemeMutualTLS value) mutualTLS,
    required TResult Function(_SecuritySchemeOauth2 value) oauth2,
    required TResult Function(_SecuritySchemeOpenIdConnect value) openIdConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SecuritySchemeApiKey value)? apiKey,
    TResult? Function(_SecuritySchemeHttp value)? http,
    TResult? Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult? Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult? Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SecuritySchemeApiKey value)? apiKey,
    TResult Function(_SecuritySchemeHttp value)? http,
    TResult Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SecuritySchemeCopyWith<SecurityScheme> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SecuritySchemeCopyWith<$Res> {
  factory $SecuritySchemeCopyWith(
          SecurityScheme value, $Res Function(SecurityScheme) then) =
      _$SecuritySchemeCopyWithImpl<$Res, SecurityScheme>;
  @useResult
  $Res call({String? description});
}

/// @nodoc
class _$SecuritySchemeCopyWithImpl<$Res, $Val extends SecurityScheme>
    implements $SecuritySchemeCopyWith<$Res> {
  _$SecuritySchemeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SecuritySchemeApiKeyCopyWith<$Res>
    implements $SecuritySchemeCopyWith<$Res> {
  factory _$$_SecuritySchemeApiKeyCopyWith(_$_SecuritySchemeApiKey value,
          $Res Function(_$_SecuritySchemeApiKey) then) =
      __$$_SecuritySchemeApiKeyCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String? description,
      @JsonKey(name: 'in') ApiKeyLocation location});
}

/// @nodoc
class __$$_SecuritySchemeApiKeyCopyWithImpl<$Res>
    extends _$SecuritySchemeCopyWithImpl<$Res, _$_SecuritySchemeApiKey>
    implements _$$_SecuritySchemeApiKeyCopyWith<$Res> {
  __$$_SecuritySchemeApiKeyCopyWithImpl(_$_SecuritySchemeApiKey _value,
      $Res Function(_$_SecuritySchemeApiKey) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? location = null,
  }) {
    return _then(_$_SecuritySchemeApiKey(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      location: null == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as ApiKeyLocation,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SecuritySchemeApiKey implements _SecuritySchemeApiKey {
  const _$_SecuritySchemeApiKey(
      {required this.name,
      this.description,
      @JsonKey(name: 'in') required this.location,
      final String? $type})
      : $type = $type ?? 'apiKey';

  factory _$_SecuritySchemeApiKey.fromJson(Map<String, dynamic> json) =>
      _$$_SecuritySchemeApiKeyFromJson(json);

  /// The name for security scheme.
  @override
  final String name;

  /// A description for security scheme.
  @override
  final String? description;

  /// The location of the API key.
  @override
  @JsonKey(name: 'in')
  final ApiKeyLocation location;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'SecurityScheme.apiKey(name: $name, description: $description, location: $location)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SecuritySchemeApiKey &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.location, location) ||
                other.location == location));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description, location);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecuritySchemeApiKeyCopyWith<_$_SecuritySchemeApiKey> get copyWith =>
      __$$_SecuritySchemeApiKeyCopyWithImpl<_$_SecuritySchemeApiKey>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)
        apiKey,
    required TResult Function(
            String scheme, String bearerFormat, String? description)
        http,
    required TResult Function(String? description) mutualTLS,
    required TResult Function(String? description, OAuthFlows flows) oauth2,
    required TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)
        openIdConnect,
  }) {
    return apiKey(name, description, location);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult? Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult? Function(String? description)? mutualTLS,
    TResult? Function(String? description, OAuthFlows flows)? oauth2,
    TResult? Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
  }) {
    return apiKey?.call(name, description, location);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult Function(String? description)? mutualTLS,
    TResult Function(String? description, OAuthFlows flows)? oauth2,
    TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
    required TResult orElse(),
  }) {
    if (apiKey != null) {
      return apiKey(name, description, location);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SecuritySchemeApiKey value) apiKey,
    required TResult Function(_SecuritySchemeHttp value) http,
    required TResult Function(_SecuritySchemeMutualTLS value) mutualTLS,
    required TResult Function(_SecuritySchemeOauth2 value) oauth2,
    required TResult Function(_SecuritySchemeOpenIdConnect value) openIdConnect,
  }) {
    return apiKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SecuritySchemeApiKey value)? apiKey,
    TResult? Function(_SecuritySchemeHttp value)? http,
    TResult? Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult? Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult? Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
  }) {
    return apiKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SecuritySchemeApiKey value)? apiKey,
    TResult Function(_SecuritySchemeHttp value)? http,
    TResult Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
    required TResult orElse(),
  }) {
    if (apiKey != null) {
      return apiKey(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SecuritySchemeApiKeyToJson(
      this,
    );
  }
}

abstract class _SecuritySchemeApiKey implements SecurityScheme {
  const factory _SecuritySchemeApiKey(
          {required final String name,
          final String? description,
          @JsonKey(name: 'in') required final ApiKeyLocation location}) =
      _$_SecuritySchemeApiKey;

  factory _SecuritySchemeApiKey.fromJson(Map<String, dynamic> json) =
      _$_SecuritySchemeApiKey.fromJson;

  /// The name for security scheme.
  String get name;
  @override

  /// A description for security scheme.
  String? get description;

  /// The location of the API key.
  @JsonKey(name: 'in')
  ApiKeyLocation get location;
  @override
  @JsonKey(ignore: true)
  _$$_SecuritySchemeApiKeyCopyWith<_$_SecuritySchemeApiKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SecuritySchemeHttpCopyWith<$Res>
    implements $SecuritySchemeCopyWith<$Res> {
  factory _$$_SecuritySchemeHttpCopyWith(_$_SecuritySchemeHttp value,
          $Res Function(_$_SecuritySchemeHttp) then) =
      __$$_SecuritySchemeHttpCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String scheme, String bearerFormat, String? description});
}

/// @nodoc
class __$$_SecuritySchemeHttpCopyWithImpl<$Res>
    extends _$SecuritySchemeCopyWithImpl<$Res, _$_SecuritySchemeHttp>
    implements _$$_SecuritySchemeHttpCopyWith<$Res> {
  __$$_SecuritySchemeHttpCopyWithImpl(
      _$_SecuritySchemeHttp _value, $Res Function(_$_SecuritySchemeHttp) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? scheme = null,
    Object? bearerFormat = null,
    Object? description = freezed,
  }) {
    return _then(_$_SecuritySchemeHttp(
      scheme: null == scheme
          ? _value.scheme
          : scheme // ignore: cast_nullable_to_non_nullable
              as String,
      bearerFormat: null == bearerFormat
          ? _value.bearerFormat
          : bearerFormat // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SecuritySchemeHttp implements _SecuritySchemeHttp {
  const _$_SecuritySchemeHttp(
      {required this.scheme,
      required this.bearerFormat,
      this.description,
      final String? $type})
      : $type = $type ?? 'http';

  factory _$_SecuritySchemeHttp.fromJson(Map<String, dynamic> json) =>
      _$$_SecuritySchemeHttpFromJson(json);

  /// The name of the HTTP Authorization scheme to be used in the Authorization header
  @override
  final String scheme;

  /// A hint to the client to identify how the bearer token is formatted.
  @override
  final String bearerFormat;

  /// A description for security scheme.
  @override
  final String? description;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'SecurityScheme.http(scheme: $scheme, bearerFormat: $bearerFormat, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SecuritySchemeHttp &&
            (identical(other.scheme, scheme) || other.scheme == scheme) &&
            (identical(other.bearerFormat, bearerFormat) ||
                other.bearerFormat == bearerFormat) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, scheme, bearerFormat, description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecuritySchemeHttpCopyWith<_$_SecuritySchemeHttp> get copyWith =>
      __$$_SecuritySchemeHttpCopyWithImpl<_$_SecuritySchemeHttp>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)
        apiKey,
    required TResult Function(
            String scheme, String bearerFormat, String? description)
        http,
    required TResult Function(String? description) mutualTLS,
    required TResult Function(String? description, OAuthFlows flows) oauth2,
    required TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)
        openIdConnect,
  }) {
    return http(scheme, bearerFormat, description);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult? Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult? Function(String? description)? mutualTLS,
    TResult? Function(String? description, OAuthFlows flows)? oauth2,
    TResult? Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
  }) {
    return http?.call(scheme, bearerFormat, description);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult Function(String? description)? mutualTLS,
    TResult Function(String? description, OAuthFlows flows)? oauth2,
    TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
    required TResult orElse(),
  }) {
    if (http != null) {
      return http(scheme, bearerFormat, description);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SecuritySchemeApiKey value) apiKey,
    required TResult Function(_SecuritySchemeHttp value) http,
    required TResult Function(_SecuritySchemeMutualTLS value) mutualTLS,
    required TResult Function(_SecuritySchemeOauth2 value) oauth2,
    required TResult Function(_SecuritySchemeOpenIdConnect value) openIdConnect,
  }) {
    return http(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SecuritySchemeApiKey value)? apiKey,
    TResult? Function(_SecuritySchemeHttp value)? http,
    TResult? Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult? Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult? Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
  }) {
    return http?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SecuritySchemeApiKey value)? apiKey,
    TResult Function(_SecuritySchemeHttp value)? http,
    TResult Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
    required TResult orElse(),
  }) {
    if (http != null) {
      return http(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SecuritySchemeHttpToJson(
      this,
    );
  }
}

abstract class _SecuritySchemeHttp implements SecurityScheme {
  const factory _SecuritySchemeHttp(
      {required final String scheme,
      required final String bearerFormat,
      final String? description}) = _$_SecuritySchemeHttp;

  factory _SecuritySchemeHttp.fromJson(Map<String, dynamic> json) =
      _$_SecuritySchemeHttp.fromJson;

  /// The name of the HTTP Authorization scheme to be used in the Authorization header
  String get scheme;

  /// A hint to the client to identify how the bearer token is formatted.
  String get bearerFormat;
  @override

  /// A description for security scheme.
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$$_SecuritySchemeHttpCopyWith<_$_SecuritySchemeHttp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SecuritySchemeMutualTLSCopyWith<$Res>
    implements $SecuritySchemeCopyWith<$Res> {
  factory _$$_SecuritySchemeMutualTLSCopyWith(_$_SecuritySchemeMutualTLS value,
          $Res Function(_$_SecuritySchemeMutualTLS) then) =
      __$$_SecuritySchemeMutualTLSCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? description});
}

/// @nodoc
class __$$_SecuritySchemeMutualTLSCopyWithImpl<$Res>
    extends _$SecuritySchemeCopyWithImpl<$Res, _$_SecuritySchemeMutualTLS>
    implements _$$_SecuritySchemeMutualTLSCopyWith<$Res> {
  __$$_SecuritySchemeMutualTLSCopyWithImpl(_$_SecuritySchemeMutualTLS _value,
      $Res Function(_$_SecuritySchemeMutualTLS) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
  }) {
    return _then(_$_SecuritySchemeMutualTLS(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SecuritySchemeMutualTLS implements _SecuritySchemeMutualTLS {
  const _$_SecuritySchemeMutualTLS({this.description, final String? $type})
      : $type = $type ?? 'mutualTLS';

  factory _$_SecuritySchemeMutualTLS.fromJson(Map<String, dynamic> json) =>
      _$$_SecuritySchemeMutualTLSFromJson(json);

  /// A description for security scheme.
  @override
  final String? description;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'SecurityScheme.mutualTLS(description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SecuritySchemeMutualTLS &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecuritySchemeMutualTLSCopyWith<_$_SecuritySchemeMutualTLS>
      get copyWith =>
          __$$_SecuritySchemeMutualTLSCopyWithImpl<_$_SecuritySchemeMutualTLS>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)
        apiKey,
    required TResult Function(
            String scheme, String bearerFormat, String? description)
        http,
    required TResult Function(String? description) mutualTLS,
    required TResult Function(String? description, OAuthFlows flows) oauth2,
    required TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)
        openIdConnect,
  }) {
    return mutualTLS(description);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult? Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult? Function(String? description)? mutualTLS,
    TResult? Function(String? description, OAuthFlows flows)? oauth2,
    TResult? Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
  }) {
    return mutualTLS?.call(description);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult Function(String? description)? mutualTLS,
    TResult Function(String? description, OAuthFlows flows)? oauth2,
    TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
    required TResult orElse(),
  }) {
    if (mutualTLS != null) {
      return mutualTLS(description);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SecuritySchemeApiKey value) apiKey,
    required TResult Function(_SecuritySchemeHttp value) http,
    required TResult Function(_SecuritySchemeMutualTLS value) mutualTLS,
    required TResult Function(_SecuritySchemeOauth2 value) oauth2,
    required TResult Function(_SecuritySchemeOpenIdConnect value) openIdConnect,
  }) {
    return mutualTLS(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SecuritySchemeApiKey value)? apiKey,
    TResult? Function(_SecuritySchemeHttp value)? http,
    TResult? Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult? Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult? Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
  }) {
    return mutualTLS?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SecuritySchemeApiKey value)? apiKey,
    TResult Function(_SecuritySchemeHttp value)? http,
    TResult Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
    required TResult orElse(),
  }) {
    if (mutualTLS != null) {
      return mutualTLS(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SecuritySchemeMutualTLSToJson(
      this,
    );
  }
}

abstract class _SecuritySchemeMutualTLS implements SecurityScheme {
  const factory _SecuritySchemeMutualTLS({final String? description}) =
      _$_SecuritySchemeMutualTLS;

  factory _SecuritySchemeMutualTLS.fromJson(Map<String, dynamic> json) =
      _$_SecuritySchemeMutualTLS.fromJson;

  @override

  /// A description for security scheme.
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$$_SecuritySchemeMutualTLSCopyWith<_$_SecuritySchemeMutualTLS>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SecuritySchemeOauth2CopyWith<$Res>
    implements $SecuritySchemeCopyWith<$Res> {
  factory _$$_SecuritySchemeOauth2CopyWith(_$_SecuritySchemeOauth2 value,
          $Res Function(_$_SecuritySchemeOauth2) then) =
      __$$_SecuritySchemeOauth2CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? description, OAuthFlows flows});

  $OAuthFlowsCopyWith<$Res> get flows;
}

/// @nodoc
class __$$_SecuritySchemeOauth2CopyWithImpl<$Res>
    extends _$SecuritySchemeCopyWithImpl<$Res, _$_SecuritySchemeOauth2>
    implements _$$_SecuritySchemeOauth2CopyWith<$Res> {
  __$$_SecuritySchemeOauth2CopyWithImpl(_$_SecuritySchemeOauth2 _value,
      $Res Function(_$_SecuritySchemeOauth2) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? flows = null,
  }) {
    return _then(_$_SecuritySchemeOauth2(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      flows: null == flows
          ? _value.flows
          : flows // ignore: cast_nullable_to_non_nullable
              as OAuthFlows,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $OAuthFlowsCopyWith<$Res> get flows {
    return $OAuthFlowsCopyWith<$Res>(_value.flows, (value) {
      return _then(_value.copyWith(flows: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$_SecuritySchemeOauth2 implements _SecuritySchemeOauth2 {
  const _$_SecuritySchemeOauth2(
      {this.description, required this.flows, final String? $type})
      : $type = $type ?? 'oauth2';

  factory _$_SecuritySchemeOauth2.fromJson(Map<String, dynamic> json) =>
      _$$_SecuritySchemeOauth2FromJson(json);

  /// A description for security scheme.
  @override
  final String? description;

  /// An object containing configuration information for the flow types supported.
  @override
  final OAuthFlows flows;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'SecurityScheme.oauth2(description: $description, flows: $flows)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SecuritySchemeOauth2 &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.flows, flows) || other.flows == flows));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description, flows);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecuritySchemeOauth2CopyWith<_$_SecuritySchemeOauth2> get copyWith =>
      __$$_SecuritySchemeOauth2CopyWithImpl<_$_SecuritySchemeOauth2>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)
        apiKey,
    required TResult Function(
            String scheme, String bearerFormat, String? description)
        http,
    required TResult Function(String? description) mutualTLS,
    required TResult Function(String? description, OAuthFlows flows) oauth2,
    required TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)
        openIdConnect,
  }) {
    return oauth2(description, flows);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult? Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult? Function(String? description)? mutualTLS,
    TResult? Function(String? description, OAuthFlows flows)? oauth2,
    TResult? Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
  }) {
    return oauth2?.call(description, flows);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult Function(String? description)? mutualTLS,
    TResult Function(String? description, OAuthFlows flows)? oauth2,
    TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
    required TResult orElse(),
  }) {
    if (oauth2 != null) {
      return oauth2(description, flows);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SecuritySchemeApiKey value) apiKey,
    required TResult Function(_SecuritySchemeHttp value) http,
    required TResult Function(_SecuritySchemeMutualTLS value) mutualTLS,
    required TResult Function(_SecuritySchemeOauth2 value) oauth2,
    required TResult Function(_SecuritySchemeOpenIdConnect value) openIdConnect,
  }) {
    return oauth2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SecuritySchemeApiKey value)? apiKey,
    TResult? Function(_SecuritySchemeHttp value)? http,
    TResult? Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult? Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult? Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
  }) {
    return oauth2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SecuritySchemeApiKey value)? apiKey,
    TResult Function(_SecuritySchemeHttp value)? http,
    TResult Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
    required TResult orElse(),
  }) {
    if (oauth2 != null) {
      return oauth2(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SecuritySchemeOauth2ToJson(
      this,
    );
  }
}

abstract class _SecuritySchemeOauth2 implements SecurityScheme {
  const factory _SecuritySchemeOauth2(
      {final String? description,
      required final OAuthFlows flows}) = _$_SecuritySchemeOauth2;

  factory _SecuritySchemeOauth2.fromJson(Map<String, dynamic> json) =
      _$_SecuritySchemeOauth2.fromJson;

  @override

  /// A description for security scheme.
  String? get description;

  /// An object containing configuration information for the flow types supported.
  OAuthFlows get flows;
  @override
  @JsonKey(ignore: true)
  _$$_SecuritySchemeOauth2CopyWith<_$_SecuritySchemeOauth2> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SecuritySchemeOpenIdConnectCopyWith<$Res>
    implements $SecuritySchemeCopyWith<$Res> {
  factory _$$_SecuritySchemeOpenIdConnectCopyWith(
          _$_SecuritySchemeOpenIdConnect value,
          $Res Function(_$_SecuritySchemeOpenIdConnect) then) =
      __$$_SecuritySchemeOpenIdConnectCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? description, @JsonKey(name: 'openIdConnectUrl') String url});
}

/// @nodoc
class __$$_SecuritySchemeOpenIdConnectCopyWithImpl<$Res>
    extends _$SecuritySchemeCopyWithImpl<$Res, _$_SecuritySchemeOpenIdConnect>
    implements _$$_SecuritySchemeOpenIdConnectCopyWith<$Res> {
  __$$_SecuritySchemeOpenIdConnectCopyWithImpl(
      _$_SecuritySchemeOpenIdConnect _value,
      $Res Function(_$_SecuritySchemeOpenIdConnect) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? description = freezed,
    Object? url = null,
  }) {
    return _then(_$_SecuritySchemeOpenIdConnect(
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SecuritySchemeOpenIdConnect implements _SecuritySchemeOpenIdConnect {
  const _$_SecuritySchemeOpenIdConnect(
      {this.description,
      @JsonKey(name: 'openIdConnectUrl') required this.url,
      final String? $type})
      : $type = $type ?? 'openIdConnect';

  factory _$_SecuritySchemeOpenIdConnect.fromJson(Map<String, dynamic> json) =>
      _$$_SecuritySchemeOpenIdConnectFromJson(json);

  /// A description for security scheme.
  @override
  final String? description;

  /// OpenId Connect URL to discover OAuth2 configuration values.
  @override
  @JsonKey(name: 'openIdConnectUrl')
  final String url;

  @JsonKey(name: 'type')
  final String $type;

  @override
  String toString() {
    return 'SecurityScheme.openIdConnect(description: $description, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SecuritySchemeOpenIdConnect &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, description, url);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecuritySchemeOpenIdConnectCopyWith<_$_SecuritySchemeOpenIdConnect>
      get copyWith => __$$_SecuritySchemeOpenIdConnectCopyWithImpl<
          _$_SecuritySchemeOpenIdConnect>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)
        apiKey,
    required TResult Function(
            String scheme, String bearerFormat, String? description)
        http,
    required TResult Function(String? description) mutualTLS,
    required TResult Function(String? description, OAuthFlows flows) oauth2,
    required TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)
        openIdConnect,
  }) {
    return openIdConnect(description, url);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult? Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult? Function(String? description)? mutualTLS,
    TResult? Function(String? description, OAuthFlows flows)? oauth2,
    TResult? Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
  }) {
    return openIdConnect?.call(description, url);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String name, String? description,
            @JsonKey(name: 'in') ApiKeyLocation location)?
        apiKey,
    TResult Function(String scheme, String bearerFormat, String? description)?
        http,
    TResult Function(String? description)? mutualTLS,
    TResult Function(String? description, OAuthFlows flows)? oauth2,
    TResult Function(
            String? description, @JsonKey(name: 'openIdConnectUrl') String url)?
        openIdConnect,
    required TResult orElse(),
  }) {
    if (openIdConnect != null) {
      return openIdConnect(description, url);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SecuritySchemeApiKey value) apiKey,
    required TResult Function(_SecuritySchemeHttp value) http,
    required TResult Function(_SecuritySchemeMutualTLS value) mutualTLS,
    required TResult Function(_SecuritySchemeOauth2 value) oauth2,
    required TResult Function(_SecuritySchemeOpenIdConnect value) openIdConnect,
  }) {
    return openIdConnect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SecuritySchemeApiKey value)? apiKey,
    TResult? Function(_SecuritySchemeHttp value)? http,
    TResult? Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult? Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult? Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
  }) {
    return openIdConnect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SecuritySchemeApiKey value)? apiKey,
    TResult Function(_SecuritySchemeHttp value)? http,
    TResult Function(_SecuritySchemeMutualTLS value)? mutualTLS,
    TResult Function(_SecuritySchemeOauth2 value)? oauth2,
    TResult Function(_SecuritySchemeOpenIdConnect value)? openIdConnect,
    required TResult orElse(),
  }) {
    if (openIdConnect != null) {
      return openIdConnect(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$_SecuritySchemeOpenIdConnectToJson(
      this,
    );
  }
}

abstract class _SecuritySchemeOpenIdConnect implements SecurityScheme {
  const factory _SecuritySchemeOpenIdConnect(
          {final String? description,
          @JsonKey(name: 'openIdConnectUrl') required final String url}) =
      _$_SecuritySchemeOpenIdConnect;

  factory _SecuritySchemeOpenIdConnect.fromJson(Map<String, dynamic> json) =
      _$_SecuritySchemeOpenIdConnect.fromJson;

  @override

  /// A description for security scheme.
  String? get description;

  /// OpenId Connect URL to discover OAuth2 configuration values.
  @JsonKey(name: 'openIdConnectUrl')
  String get url;
  @override
  @JsonKey(ignore: true)
  _$$_SecuritySchemeOpenIdConnectCopyWith<_$_SecuritySchemeOpenIdConnect>
      get copyWith => throw _privateConstructorUsedError;
}

Server _$ServerFromJson(Map<String, dynamic> json) {
  return _Server.fromJson(json);
}

/// @nodoc
mixin _$Server {
  /// A URL to the target host. This URL supports Server Variables and may
  /// be relative, to indicate that the host location is relative to the
  /// location where the OpenAPI document is being served. Variable
  /// substitutions will be made when a variable is named in {brackets}.
  String? get url => throw _privateConstructorUsedError;

  /// An optional string describing the host designated by the URL.
  String? get description => throw _privateConstructorUsedError;

  /// A map between a variable name and its value.
  /// The value is used for substitution in the server's URL template.
  Map<String, ServerVariable>? get variables =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ServerCopyWith<Server> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ServerCopyWith<$Res> {
  factory $ServerCopyWith(Server value, $Res Function(Server) then) =
      _$ServerCopyWithImpl<$Res, Server>;
  @useResult
  $Res call(
      {String? url,
      String? description,
      Map<String, ServerVariable>? variables});
}

/// @nodoc
class _$ServerCopyWithImpl<$Res, $Val extends Server>
    implements $ServerCopyWith<$Res> {
  _$ServerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? description = freezed,
    Object? variables = freezed,
  }) {
    return _then(_value.copyWith(
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      variables: freezed == variables
          ? _value.variables
          : variables // ignore: cast_nullable_to_non_nullable
              as Map<String, ServerVariable>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ServerCopyWith<$Res> implements $ServerCopyWith<$Res> {
  factory _$$_ServerCopyWith(_$_Server value, $Res Function(_$_Server) then) =
      __$$_ServerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? url,
      String? description,
      Map<String, ServerVariable>? variables});
}

/// @nodoc
class __$$_ServerCopyWithImpl<$Res>
    extends _$ServerCopyWithImpl<$Res, _$_Server>
    implements _$$_ServerCopyWith<$Res> {
  __$$_ServerCopyWithImpl(_$_Server _value, $Res Function(_$_Server) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = freezed,
    Object? description = freezed,
    Object? variables = freezed,
  }) {
    return _then(_$_Server(
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      variables: freezed == variables
          ? _value._variables
          : variables // ignore: cast_nullable_to_non_nullable
              as Map<String, ServerVariable>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Server implements _Server {
  const _$_Server(
      {this.url,
      this.description,
      final Map<String, ServerVariable>? variables})
      : _variables = variables;

  factory _$_Server.fromJson(Map<String, dynamic> json) =>
      _$$_ServerFromJson(json);

  /// A URL to the target host. This URL supports Server Variables and may
  /// be relative, to indicate that the host location is relative to the
  /// location where the OpenAPI document is being served. Variable
  /// substitutions will be made when a variable is named in {brackets}.
  @override
  final String? url;

  /// An optional string describing the host designated by the URL.
  @override
  final String? description;

  /// A map between a variable name and its value.
  /// The value is used for substitution in the server's URL template.
  final Map<String, ServerVariable>? _variables;

  /// A map between a variable name and its value.
  /// The value is used for substitution in the server's URL template.
  @override
  Map<String, ServerVariable>? get variables {
    final value = _variables;
    if (value == null) return null;
    if (_variables is EqualUnmodifiableMapView) return _variables;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'Server(url: $url, description: $description, variables: $variables)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Server &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other._variables, _variables));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, description,
      const DeepCollectionEquality().hash(_variables));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ServerCopyWith<_$_Server> get copyWith =>
      __$$_ServerCopyWithImpl<_$_Server>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ServerToJson(
      this,
    );
  }
}

abstract class _Server implements Server {
  const factory _Server(
      {final String? url,
      final String? description,
      final Map<String, ServerVariable>? variables}) = _$_Server;

  factory _Server.fromJson(Map<String, dynamic> json) = _$_Server.fromJson;

  @override

  /// A URL to the target host. This URL supports Server Variables and may
  /// be relative, to indicate that the host location is relative to the
  /// location where the OpenAPI document is being served. Variable
  /// substitutions will be made when a variable is named in {brackets}.
  String? get url;
  @override

  /// An optional string describing the host designated by the URL.
  String? get description;
  @override

  /// A map between a variable name and its value.
  /// The value is used for substitution in the server's URL template.
  Map<String, ServerVariable>? get variables;
  @override
  @JsonKey(ignore: true)
  _$$_ServerCopyWith<_$_Server> get copyWith =>
      throw _privateConstructorUsedError;
}

ServerVariable _$ServerVariableFromJson(Map<String, dynamic> json) {
  return _ServerVariable.fromJson(json);
}

/// @nodoc
mixin _$ServerVariable {
  /// An enumeration of string values to be used if the substitution
  /// options are from a limited set. The array must not be empty.
  @JsonKey(name: 'enum')
  List<String>? get enumValue => throw _privateConstructorUsedError;

  /// The default value to use for substitution, which SHALL be sent if an alternate
  /// value is not supplied. Note this behavior is different than the Schema Object's
  /// treatment of default values, because in those cases parameter values are optional.
  /// If the enum is defined, the value must exist in the enum's values.
  @JsonKey(name: 'default')
  String get defaultValue => throw _privateConstructorUsedError;

  /// An optional string describing the host designated by the URL.
  String? get description => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ServerVariableCopyWith<ServerVariable> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ServerVariableCopyWith<$Res> {
  factory $ServerVariableCopyWith(
          ServerVariable value, $Res Function(ServerVariable) then) =
      _$ServerVariableCopyWithImpl<$Res, ServerVariable>;
  @useResult
  $Res call(
      {@JsonKey(name: 'enum') List<String>? enumValue,
      @JsonKey(name: 'default') String defaultValue,
      String? description});
}

/// @nodoc
class _$ServerVariableCopyWithImpl<$Res, $Val extends ServerVariable>
    implements $ServerVariableCopyWith<$Res> {
  _$ServerVariableCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enumValue = freezed,
    Object? defaultValue = null,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      enumValue: freezed == enumValue
          ? _value.enumValue
          : enumValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      defaultValue: null == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ServerVariableCopyWith<$Res>
    implements $ServerVariableCopyWith<$Res> {
  factory _$$_ServerVariableCopyWith(
          _$_ServerVariable value, $Res Function(_$_ServerVariable) then) =
      __$$_ServerVariableCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'enum') List<String>? enumValue,
      @JsonKey(name: 'default') String defaultValue,
      String? description});
}

/// @nodoc
class __$$_ServerVariableCopyWithImpl<$Res>
    extends _$ServerVariableCopyWithImpl<$Res, _$_ServerVariable>
    implements _$$_ServerVariableCopyWith<$Res> {
  __$$_ServerVariableCopyWithImpl(
      _$_ServerVariable _value, $Res Function(_$_ServerVariable) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enumValue = freezed,
    Object? defaultValue = null,
    Object? description = freezed,
  }) {
    return _then(_$_ServerVariable(
      enumValue: freezed == enumValue
          ? _value._enumValue
          : enumValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      defaultValue: null == defaultValue
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ServerVariable implements _ServerVariable {
  const _$_ServerVariable(
      {@JsonKey(name: 'enum') final List<String>? enumValue,
      @JsonKey(name: 'default') required this.defaultValue,
      this.description})
      : _enumValue = enumValue;

  factory _$_ServerVariable.fromJson(Map<String, dynamic> json) =>
      _$$_ServerVariableFromJson(json);

  /// An enumeration of string values to be used if the substitution
  /// options are from a limited set. The array must not be empty.
  final List<String>? _enumValue;

  /// An enumeration of string values to be used if the substitution
  /// options are from a limited set. The array must not be empty.
  @override
  @JsonKey(name: 'enum')
  List<String>? get enumValue {
    final value = _enumValue;
    if (value == null) return null;
    if (_enumValue is EqualUnmodifiableListView) return _enumValue;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The default value to use for substitution, which SHALL be sent if an alternate
  /// value is not supplied. Note this behavior is different than the Schema Object's
  /// treatment of default values, because in those cases parameter values are optional.
  /// If the enum is defined, the value must exist in the enum's values.
  @override
  @JsonKey(name: 'default')
  final String defaultValue;

  /// An optional string describing the host designated by the URL.
  @override
  final String? description;

  @override
  String toString() {
    return 'ServerVariable(enumValue: $enumValue, defaultValue: $defaultValue, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ServerVariable &&
            const DeepCollectionEquality()
                .equals(other._enumValue, _enumValue) &&
            (identical(other.defaultValue, defaultValue) ||
                other.defaultValue == defaultValue) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_enumValue),
      defaultValue,
      description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ServerVariableCopyWith<_$_ServerVariable> get copyWith =>
      __$$_ServerVariableCopyWithImpl<_$_ServerVariable>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ServerVariableToJson(
      this,
    );
  }
}

abstract class _ServerVariable implements ServerVariable {
  const factory _ServerVariable(
      {@JsonKey(name: 'enum') final List<String>? enumValue,
      @JsonKey(name: 'default') required final String defaultValue,
      final String? description}) = _$_ServerVariable;

  factory _ServerVariable.fromJson(Map<String, dynamic> json) =
      _$_ServerVariable.fromJson;

  @override

  /// An enumeration of string values to be used if the substitution
  /// options are from a limited set. The array must not be empty.
  @JsonKey(name: 'enum')
  List<String>? get enumValue;
  @override

  /// The default value to use for substitution, which SHALL be sent if an alternate
  /// value is not supplied. Note this behavior is different than the Schema Object's
  /// treatment of default values, because in those cases parameter values are optional.
  /// If the enum is defined, the value must exist in the enum's values.
  @JsonKey(name: 'default')
  String get defaultValue;
  @override

  /// An optional string describing the host designated by the URL.
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$$_ServerVariableCopyWith<_$_ServerVariable> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$OpenApi {
  /// This string must be the version number of the
  /// OpenAPI Specification that the OpenAPI document uses.
  /// This is not related to the API [Info.version] string.
  /// By default, this generator uses `3.1.0`.
  @JsonKey(name: 'openapi')
  String get version => throw _privateConstructorUsedError;

  /// Provides metadata about the API.
  /// The metadata MAY be used by tooling as required.
  Info get info => throw _privateConstructorUsedError;

  /// Additional external documentation.
  ExternalDocs? get externalDocs => throw _privateConstructorUsedError;

  /// The default value for the $schema keyword within
  /// Schema Objects contained within this OAS document
  /// This must be in the form of a URI.
  String? get jsonSchemaDialect => throw _privateConstructorUsedError;

  /// An array of [Server] objects, which provide connectivity information to a target server.
  /// If the servers property is not provided, or is an empty array,
  /// the default value would be a [Server] object with a url value of `/`.
  List<Server>? get servers => throw _privateConstructorUsedError;

  /// can be included in the array.
  List<Tag>? get tags => throw _privateConstructorUsedError;

  /// The available paths and operations for the API.
  Map<String, PathItem>? get paths => throw _privateConstructorUsedError;

  /// The incoming webhooks that may be received as part of this
  /// API and that the API consumer MAY choose to implement.
  /// Closely related to the callbacks feature, this section describes
  /// requests initiated other than by an API call, for example by an out of
  /// band registration. The key name is a unique string to refer to each
  /// webhook, while the (optionally referenced) path Item Object describes a
  /// request that may be initiated by the API provider and the expected responses.
  Map<String, PathItem>? get webhooks => throw _privateConstructorUsedError;

  /// An element to hold various schemas for the document.
  Components? get components => throw _privateConstructorUsedError;

  /// A declaration of which security mechanisms can be used across the API.
  /// The list of values includes alternative security requirement objects
  /// that can be used. Only one of the security requirement objects need
  /// to be satisfied to authorize a request. Individual operations can override
  /// this definition. To make security optional, an empty security requirement ({})
  /// can be included in the array.
  List<Security>? get security => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OpenApiCopyWith<OpenApi> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenApiCopyWith<$Res> {
  factory $OpenApiCopyWith(OpenApi value, $Res Function(OpenApi) then) =
      _$OpenApiCopyWithImpl<$Res, OpenApi>;
  @useResult
  $Res call(
      {@JsonKey(name: 'openapi') String version,
      Info info,
      ExternalDocs? externalDocs,
      String? jsonSchemaDialect,
      List<Server>? servers,
      List<Tag>? tags,
      Map<String, PathItem>? paths,
      Map<String, PathItem>? webhooks,
      Components? components,
      List<Security>? security});

  $InfoCopyWith<$Res> get info;
  $ExternalDocsCopyWith<$Res>? get externalDocs;
  $ComponentsCopyWith<$Res>? get components;
}

/// @nodoc
class _$OpenApiCopyWithImpl<$Res, $Val extends OpenApi>
    implements $OpenApiCopyWith<$Res> {
  _$OpenApiCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? info = null,
    Object? externalDocs = freezed,
    Object? jsonSchemaDialect = freezed,
    Object? servers = freezed,
    Object? tags = freezed,
    Object? paths = freezed,
    Object? webhooks = freezed,
    Object? components = freezed,
    Object? security = freezed,
  }) {
    return _then(_value.copyWith(
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String,
      info: null == info
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as Info,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
      jsonSchemaDialect: freezed == jsonSchemaDialect
          ? _value.jsonSchemaDialect
          : jsonSchemaDialect // ignore: cast_nullable_to_non_nullable
              as String?,
      servers: freezed == servers
          ? _value.servers
          : servers // ignore: cast_nullable_to_non_nullable
              as List<Server>?,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      paths: freezed == paths
          ? _value.paths
          : paths // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>?,
      webhooks: freezed == webhooks
          ? _value.webhooks
          : webhooks // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>?,
      components: freezed == components
          ? _value.components
          : components // ignore: cast_nullable_to_non_nullable
              as Components?,
      security: freezed == security
          ? _value.security
          : security // ignore: cast_nullable_to_non_nullable
              as List<Security>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $InfoCopyWith<$Res> get info {
    return $InfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalDocsCopyWith<$Res>? get externalDocs {
    if (_value.externalDocs == null) {
      return null;
    }

    return $ExternalDocsCopyWith<$Res>(_value.externalDocs!, (value) {
      return _then(_value.copyWith(externalDocs: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ComponentsCopyWith<$Res>? get components {
    if (_value.components == null) {
      return null;
    }

    return $ComponentsCopyWith<$Res>(_value.components!, (value) {
      return _then(_value.copyWith(components: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_OpenApiCopyWith<$Res> implements $OpenApiCopyWith<$Res> {
  factory _$$_OpenApiCopyWith(
          _$_OpenApi value, $Res Function(_$_OpenApi) then) =
      __$$_OpenApiCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'openapi') String version,
      Info info,
      ExternalDocs? externalDocs,
      String? jsonSchemaDialect,
      List<Server>? servers,
      List<Tag>? tags,
      Map<String, PathItem>? paths,
      Map<String, PathItem>? webhooks,
      Components? components,
      List<Security>? security});

  @override
  $InfoCopyWith<$Res> get info;
  @override
  $ExternalDocsCopyWith<$Res>? get externalDocs;
  @override
  $ComponentsCopyWith<$Res>? get components;
}

/// @nodoc
class __$$_OpenApiCopyWithImpl<$Res>
    extends _$OpenApiCopyWithImpl<$Res, _$_OpenApi>
    implements _$$_OpenApiCopyWith<$Res> {
  __$$_OpenApiCopyWithImpl(_$_OpenApi _value, $Res Function(_$_OpenApi) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? info = null,
    Object? externalDocs = freezed,
    Object? jsonSchemaDialect = freezed,
    Object? servers = freezed,
    Object? tags = freezed,
    Object? paths = freezed,
    Object? webhooks = freezed,
    Object? components = freezed,
    Object? security = freezed,
  }) {
    return _then(_$_OpenApi(
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String,
      info: null == info
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as Info,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
      jsonSchemaDialect: freezed == jsonSchemaDialect
          ? _value.jsonSchemaDialect
          : jsonSchemaDialect // ignore: cast_nullable_to_non_nullable
              as String?,
      servers: freezed == servers
          ? _value._servers
          : servers // ignore: cast_nullable_to_non_nullable
              as List<Server>?,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      paths: freezed == paths
          ? _value._paths
          : paths // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>?,
      webhooks: freezed == webhooks
          ? _value._webhooks
          : webhooks // ignore: cast_nullable_to_non_nullable
              as Map<String, PathItem>?,
      components: freezed == components
          ? _value.components
          : components // ignore: cast_nullable_to_non_nullable
              as Components?,
      security: freezed == security
          ? _value._security
          : security // ignore: cast_nullable_to_non_nullable
              as List<Security>?,
    ));
  }
}

/// @nodoc

class _$_OpenApi extends _OpenApi {
  const _$_OpenApi(
      {@JsonKey(name: 'openapi') this.version = '3.1.0',
      required this.info,
      this.externalDocs,
      this.jsonSchemaDialect,
      final List<Server>? servers,
      final List<Tag>? tags,
      final Map<String, PathItem>? paths,
      final Map<String, PathItem>? webhooks,
      this.components,
      final List<Security>? security})
      : _servers = servers,
        _tags = tags,
        _paths = paths,
        _webhooks = webhooks,
        _security = security,
        super._();

  /// This string must be the version number of the
  /// OpenAPI Specification that the OpenAPI document uses.
  /// This is not related to the API [Info.version] string.
  /// By default, this generator uses `3.1.0`.
  @override
  @JsonKey(name: 'openapi')
  final String version;

  /// Provides metadata about the API.
  /// The metadata MAY be used by tooling as required.
  @override
  final Info info;

  /// Additional external documentation.
  @override
  final ExternalDocs? externalDocs;

  /// The default value for the $schema keyword within
  /// Schema Objects contained within this OAS document
  /// This must be in the form of a URI.
  @override
  final String? jsonSchemaDialect;

  /// An array of [Server] objects, which provide connectivity information to a target server.
  /// If the servers property is not provided, or is an empty array,
  /// the default value would be a [Server] object with a url value of `/`.
  final List<Server>? _servers;

  /// An array of [Server] objects, which provide connectivity information to a target server.
  /// If the servers property is not provided, or is an empty array,
  /// the default value would be a [Server] object with a url value of `/`.
  @override
  List<Server>? get servers {
    final value = _servers;
    if (value == null) return null;
    if (_servers is EqualUnmodifiableListView) return _servers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// can be included in the array.
  final List<Tag>? _tags;

  /// can be included in the array.
  @override
  List<Tag>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The available paths and operations for the API.
  final Map<String, PathItem>? _paths;

  /// The available paths and operations for the API.
  @override
  Map<String, PathItem>? get paths {
    final value = _paths;
    if (value == null) return null;
    if (_paths is EqualUnmodifiableMapView) return _paths;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// The incoming webhooks that may be received as part of this
  /// API and that the API consumer MAY choose to implement.
  /// Closely related to the callbacks feature, this section describes
  /// requests initiated other than by an API call, for example by an out of
  /// band registration. The key name is a unique string to refer to each
  /// webhook, while the (optionally referenced) path Item Object describes a
  /// request that may be initiated by the API provider and the expected responses.
  final Map<String, PathItem>? _webhooks;

  /// The incoming webhooks that may be received as part of this
  /// API and that the API consumer MAY choose to implement.
  /// Closely related to the callbacks feature, this section describes
  /// requests initiated other than by an API call, for example by an out of
  /// band registration. The key name is a unique string to refer to each
  /// webhook, while the (optionally referenced) path Item Object describes a
  /// request that may be initiated by the API provider and the expected responses.
  @override
  Map<String, PathItem>? get webhooks {
    final value = _webhooks;
    if (value == null) return null;
    if (_webhooks is EqualUnmodifiableMapView) return _webhooks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// An element to hold various schemas for the document.
  @override
  final Components? components;

  /// A declaration of which security mechanisms can be used across the API.
  /// The list of values includes alternative security requirement objects
  /// that can be used. Only one of the security requirement objects need
  /// to be satisfied to authorize a request. Individual operations can override
  /// this definition. To make security optional, an empty security requirement ({})
  /// can be included in the array.
  final List<Security>? _security;

  /// A declaration of which security mechanisms can be used across the API.
  /// The list of values includes alternative security requirement objects
  /// that can be used. Only one of the security requirement objects need
  /// to be satisfied to authorize a request. Individual operations can override
  /// this definition. To make security optional, an empty security requirement ({})
  /// can be included in the array.
  @override
  List<Security>? get security {
    final value = _security;
    if (value == null) return null;
    if (_security is EqualUnmodifiableListView) return _security;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'OpenApi(version: $version, info: $info, externalDocs: $externalDocs, jsonSchemaDialect: $jsonSchemaDialect, servers: $servers, tags: $tags, paths: $paths, webhooks: $webhooks, components: $components, security: $security)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OpenApi &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.info, info) || other.info == info) &&
            (identical(other.externalDocs, externalDocs) ||
                other.externalDocs == externalDocs) &&
            (identical(other.jsonSchemaDialect, jsonSchemaDialect) ||
                other.jsonSchemaDialect == jsonSchemaDialect) &&
            const DeepCollectionEquality().equals(other._servers, _servers) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            const DeepCollectionEquality().equals(other._paths, _paths) &&
            const DeepCollectionEquality().equals(other._webhooks, _webhooks) &&
            (identical(other.components, components) ||
                other.components == components) &&
            const DeepCollectionEquality().equals(other._security, _security));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      version,
      info,
      externalDocs,
      jsonSchemaDialect,
      const DeepCollectionEquality().hash(_servers),
      const DeepCollectionEquality().hash(_tags),
      const DeepCollectionEquality().hash(_paths),
      const DeepCollectionEquality().hash(_webhooks),
      components,
      const DeepCollectionEquality().hash(_security));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OpenApiCopyWith<_$_OpenApi> get copyWith =>
      __$$_OpenApiCopyWithImpl<_$_OpenApi>(this, _$identity);
}

abstract class _OpenApi extends OpenApi {
  const factory _OpenApi(
      {@JsonKey(name: 'openapi') final String version,
      required final Info info,
      final ExternalDocs? externalDocs,
      final String? jsonSchemaDialect,
      final List<Server>? servers,
      final List<Tag>? tags,
      final Map<String, PathItem>? paths,
      final Map<String, PathItem>? webhooks,
      final Components? components,
      final List<Security>? security}) = _$_OpenApi;
  const _OpenApi._() : super._();

  @override

  /// This string must be the version number of the
  /// OpenAPI Specification that the OpenAPI document uses.
  /// This is not related to the API [Info.version] string.
  /// By default, this generator uses `3.1.0`.
  @JsonKey(name: 'openapi')
  String get version;
  @override

  /// Provides metadata about the API.
  /// The metadata MAY be used by tooling as required.
  Info get info;
  @override

  /// Additional external documentation.
  ExternalDocs? get externalDocs;
  @override

  /// The default value for the $schema keyword within
  /// Schema Objects contained within this OAS document
  /// This must be in the form of a URI.
  String? get jsonSchemaDialect;
  @override

  /// An array of [Server] objects, which provide connectivity information to a target server.
  /// If the servers property is not provided, or is an empty array,
  /// the default value would be a [Server] object with a url value of `/`.
  List<Server>? get servers;
  @override

  /// can be included in the array.
  List<Tag>? get tags;
  @override

  /// The available paths and operations for the API.
  Map<String, PathItem>? get paths;
  @override

  /// The incoming webhooks that may be received as part of this
  /// API and that the API consumer MAY choose to implement.
  /// Closely related to the callbacks feature, this section describes
  /// requests initiated other than by an API call, for example by an out of
  /// band registration. The key name is a unique string to refer to each
  /// webhook, while the (optionally referenced) path Item Object describes a
  /// request that may be initiated by the API provider and the expected responses.
  Map<String, PathItem>? get webhooks;
  @override

  /// An element to hold various schemas for the document.
  Components? get components;
  @override

  /// A declaration of which security mechanisms can be used across the API.
  /// The list of values includes alternative security requirement objects
  /// that can be used. Only one of the security requirement objects need
  /// to be satisfied to authorize a request. Individual operations can override
  /// this definition. To make security optional, an empty security requirement ({})
  /// can be included in the array.
  List<Security>? get security;
  @override
  @JsonKey(ignore: true)
  _$$_OpenApiCopyWith<_$_OpenApi> get copyWith =>
      throw _privateConstructorUsedError;
}

Tag _$TagFromJson(Map<String, dynamic> json) {
  return _Tag.fromJson(json);
}

/// @nodoc
mixin _$Tag {
  /// The name of the tag.
  String get name => throw _privateConstructorUsedError;

  /// A description of the API.
  String? get description => throw _privateConstructorUsedError;

  /// Additional external documentation for this tag.
  ExternalDocs? get externalDocs => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TagCopyWith<Tag> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TagCopyWith<$Res> {
  factory $TagCopyWith(Tag value, $Res Function(Tag) then) =
      _$TagCopyWithImpl<$Res, Tag>;
  @useResult
  $Res call({String name, String? description, ExternalDocs? externalDocs});

  $ExternalDocsCopyWith<$Res>? get externalDocs;
}

/// @nodoc
class _$TagCopyWithImpl<$Res, $Val extends Tag> implements $TagCopyWith<$Res> {
  _$TagCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? externalDocs = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalDocsCopyWith<$Res>? get externalDocs {
    if (_value.externalDocs == null) {
      return null;
    }

    return $ExternalDocsCopyWith<$Res>(_value.externalDocs!, (value) {
      return _then(_value.copyWith(externalDocs: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TagCopyWith<$Res> implements $TagCopyWith<$Res> {
  factory _$$_TagCopyWith(_$_Tag value, $Res Function(_$_Tag) then) =
      __$$_TagCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String? description, ExternalDocs? externalDocs});

  @override
  $ExternalDocsCopyWith<$Res>? get externalDocs;
}

/// @nodoc
class __$$_TagCopyWithImpl<$Res> extends _$TagCopyWithImpl<$Res, _$_Tag>
    implements _$$_TagCopyWith<$Res> {
  __$$_TagCopyWithImpl(_$_Tag _value, $Res Function(_$_Tag) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? description = freezed,
    Object? externalDocs = freezed,
  }) {
    return _then(_$_Tag(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      externalDocs: freezed == externalDocs
          ? _value.externalDocs
          : externalDocs // ignore: cast_nullable_to_non_nullable
              as ExternalDocs?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Tag implements _Tag {
  const _$_Tag({required this.name, this.description, this.externalDocs});

  factory _$_Tag.fromJson(Map<String, dynamic> json) => _$$_TagFromJson(json);

  /// The name of the tag.
  @override
  final String name;

  /// A description of the API.
  @override
  final String? description;

  /// Additional external documentation for this tag.
  @override
  final ExternalDocs? externalDocs;

  @override
  String toString() {
    return 'Tag(name: $name, description: $description, externalDocs: $externalDocs)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Tag &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.externalDocs, externalDocs) ||
                other.externalDocs == externalDocs));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, description, externalDocs);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TagCopyWith<_$_Tag> get copyWith =>
      __$$_TagCopyWithImpl<_$_Tag>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TagToJson(
      this,
    );
  }
}

abstract class _Tag implements Tag {
  const factory _Tag(
      {required final String name,
      final String? description,
      final ExternalDocs? externalDocs}) = _$_Tag;

  factory _Tag.fromJson(Map<String, dynamic> json) = _$_Tag.fromJson;

  @override

  /// The name of the tag.
  String get name;
  @override

  /// A description of the API.
  String? get description;
  @override

  /// Additional external documentation for this tag.
  ExternalDocs? get externalDocs;
  @override
  @JsonKey(ignore: true)
  _$$_TagCopyWith<_$_Tag> get copyWith => throw _privateConstructorUsedError;
}

Xml _$XmlFromJson(Map<String, dynamic> json) {
  return _Xml.fromJson(json);
}

/// @nodoc
mixin _$Xml {
  /// Replaces the name of the element/attribute used for the described schema property
  String? get name => throw _privateConstructorUsedError;

  /// The URI of the namespace definition
  /// This must be in the form of an absolute URI.
  String? get namespace => throw _privateConstructorUsedError;

  /// The prefix to be used for the [name].
  String? get prefix => throw _privateConstructorUsedError;

  /// Declares whether the property definition translates to an attribute instead of an element
  bool? get attribute => throw _privateConstructorUsedError;

  /// May be used only for an array definition
  bool? get wrapped => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $XmlCopyWith<Xml> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $XmlCopyWith<$Res> {
  factory $XmlCopyWith(Xml value, $Res Function(Xml) then) =
      _$XmlCopyWithImpl<$Res, Xml>;
  @useResult
  $Res call(
      {String? name,
      String? namespace,
      String? prefix,
      bool? attribute,
      bool? wrapped});
}

/// @nodoc
class _$XmlCopyWithImpl<$Res, $Val extends Xml> implements $XmlCopyWith<$Res> {
  _$XmlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? namespace = freezed,
    Object? prefix = freezed,
    Object? attribute = freezed,
    Object? wrapped = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      namespace: freezed == namespace
          ? _value.namespace
          : namespace // ignore: cast_nullable_to_non_nullable
              as String?,
      prefix: freezed == prefix
          ? _value.prefix
          : prefix // ignore: cast_nullable_to_non_nullable
              as String?,
      attribute: freezed == attribute
          ? _value.attribute
          : attribute // ignore: cast_nullable_to_non_nullable
              as bool?,
      wrapped: freezed == wrapped
          ? _value.wrapped
          : wrapped // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_XmlCopyWith<$Res> implements $XmlCopyWith<$Res> {
  factory _$$_XmlCopyWith(_$_Xml value, $Res Function(_$_Xml) then) =
      __$$_XmlCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? namespace,
      String? prefix,
      bool? attribute,
      bool? wrapped});
}

/// @nodoc
class __$$_XmlCopyWithImpl<$Res> extends _$XmlCopyWithImpl<$Res, _$_Xml>
    implements _$$_XmlCopyWith<$Res> {
  __$$_XmlCopyWithImpl(_$_Xml _value, $Res Function(_$_Xml) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? namespace = freezed,
    Object? prefix = freezed,
    Object? attribute = freezed,
    Object? wrapped = freezed,
  }) {
    return _then(_$_Xml(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      namespace: freezed == namespace
          ? _value.namespace
          : namespace // ignore: cast_nullable_to_non_nullable
              as String?,
      prefix: freezed == prefix
          ? _value.prefix
          : prefix // ignore: cast_nullable_to_non_nullable
              as String?,
      attribute: freezed == attribute
          ? _value.attribute
          : attribute // ignore: cast_nullable_to_non_nullable
              as bool?,
      wrapped: freezed == wrapped
          ? _value.wrapped
          : wrapped // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Xml implements _Xml {
  const _$_Xml(
      {this.name, this.namespace, this.prefix, this.attribute, this.wrapped});

  factory _$_Xml.fromJson(Map<String, dynamic> json) => _$$_XmlFromJson(json);

  /// Replaces the name of the element/attribute used for the described schema property
  @override
  final String? name;

  /// The URI of the namespace definition
  /// This must be in the form of an absolute URI.
  @override
  final String? namespace;

  /// The prefix to be used for the [name].
  @override
  final String? prefix;

  /// Declares whether the property definition translates to an attribute instead of an element
  @override
  final bool? attribute;

  /// May be used only for an array definition
  @override
  final bool? wrapped;

  @override
  String toString() {
    return 'Xml(name: $name, namespace: $namespace, prefix: $prefix, attribute: $attribute, wrapped: $wrapped)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Xml &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.namespace, namespace) ||
                other.namespace == namespace) &&
            (identical(other.prefix, prefix) || other.prefix == prefix) &&
            (identical(other.attribute, attribute) ||
                other.attribute == attribute) &&
            (identical(other.wrapped, wrapped) || other.wrapped == wrapped));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, name, namespace, prefix, attribute, wrapped);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_XmlCopyWith<_$_Xml> get copyWith =>
      __$$_XmlCopyWithImpl<_$_Xml>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_XmlToJson(
      this,
    );
  }
}

abstract class _Xml implements Xml {
  const factory _Xml(
      {final String? name,
      final String? namespace,
      final String? prefix,
      final bool? attribute,
      final bool? wrapped}) = _$_Xml;

  factory _Xml.fromJson(Map<String, dynamic> json) = _$_Xml.fromJson;

  @override

  /// Replaces the name of the element/attribute used for the described schema property
  String? get name;
  @override

  /// The URI of the namespace definition
  /// This must be in the form of an absolute URI.
  String? get namespace;
  @override

  /// The prefix to be used for the [name].
  String? get prefix;
  @override

  /// Declares whether the property definition translates to an attribute instead of an element
  bool? get attribute;
  @override

  /// May be used only for an array definition
  bool? get wrapped;
  @override
  @JsonKey(ignore: true)
  _$$_XmlCopyWith<_$_Xml> get copyWith => throw _privateConstructorUsedError;
}
